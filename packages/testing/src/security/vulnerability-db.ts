/**
 * Vulnerability Database
 * Manages vulnerability data from various sources (OSV, NVD, etc.)
 */

import { createHash } from "crypto";
import {
  Vulnerability,
  SecuritySeverity,
  DependencyInfo
} from "./types.js";
import { NODE_PACKAGE_ECOSYSTEM } from "./ecosystems.js";

export interface VulnerabilitySource {
  name: string;
  url: string;
  ecosystem: string[];
  enabled: boolean;
}

export interface OSVResponse {
  vulns?: OSVVulnerability[];
}

export interface OSVVulnerability {
  id: string;
  summary?: string;
  details?: string;
  aliases?: string[];
  published?: string;
  modified?: string;
  affected?: OSVAffected[];
  severity?: OSVSeverity[];
  database_specific?: {
    severity?: string;
    cve?: string;
  };
}

export interface OSVAffected {
  package?: {
    name?: string;
    ecosystem?: string;
  };
  ranges?: OSVRange[];
}

export interface OSVRange {
  type?: string;
  events?: OSVEvent[];
}

export interface OSVEvent {
  introduced?: string;
  fixed?: string;
}

export interface OSVSeverity {
  type?: string;
  score?: number | string;
}

export class VulnerabilityDatabase {
  private cache: Map<string, Vulnerability[]> = new Map();
  private sources: VulnerabilitySource[] = [];
  private readonly CACHE_TTL = 24 * 60 * 60 * 1000; // 24 hours
  private cacheTimestamps: Map<string, number> = new Map();

  async initialize(): Promise<void> {
    this.loadSources();
  }

  async checkVulnerabilities(
    packageName: string,
    version: string,
    ecosystem: string = NODE_PACKAGE_ECOSYSTEM
  ): Promise<Vulnerability[]> {
    const cacheKey = `${ecosystem}:${packageName}@${version}`;

    // Check cache first
    if (this.isCacheValid(cacheKey)) {
      return this.cache.get(cacheKey) || [];
    }

    const vulnerabilities: Vulnerability[] = [];

    try {
      // Try OSV API first (most comprehensive)
      if (this.isOSVEnabled()) {
        const osvVulns = await this.fetchOSVVulnerabilities(packageName, version, ecosystem);
        vulnerabilities.push(...osvVulns);
      }

      // Fallback to local/mock data for testing
      if (vulnerabilities.length === 0) {
        const mockVulns = this.getMockVulnerabilities(packageName, version);
        vulnerabilities.push(...mockVulns);
      }

      // Cache results
      this.cache.set(cacheKey, vulnerabilities);
      this.cacheTimestamps.set(cacheKey, Date.now());

    } catch (error) {
      console.warn(`Failed to fetch vulnerabilities for ${packageName}@${version}:`, error);

      // Return cached data if available, even if stale
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey) || [];
      }
    }

    return vulnerabilities;
  }

  async batchCheckVulnerabilities(
    dependencies: DependencyInfo[]
  ): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Group dependencies by ecosystem for efficient batching
    const byEcosystem = new Map<string, DependencyInfo[]>();
    for (const dep of dependencies) {
      const deps = byEcosystem.get(dep.ecosystem) || [];
      deps.push(dep);
      byEcosystem.set(dep.ecosystem, deps);
    }

    // Process each ecosystem separately
    for (const [ecosystem, deps] of byEcosystem) {
      try {
        if (ecosystem === NODE_PACKAGE_ECOSYSTEM && this.isOSVEnabled()) {
          const batchVulns = await this.fetchOSVBatch(deps);
          vulnerabilities.push(...batchVulns);
        } else {
          // Fallback to individual checks
          for (const dep of deps) {
            const vulns = await this.checkVulnerabilities(dep.name, dep.version, dep.ecosystem);
            vulnerabilities.push(...vulns);
          }
        }
      } catch (error) {
        console.warn(`Batch vulnerability check failed for ${ecosystem}:`, error);
      }
    }

    return vulnerabilities;
  }

  async updateDatabase(): Promise<void> {
    console.log("ðŸ”„ Updating vulnerability database...");

    // Clear cache to force fresh data
    this.cache.clear();
    this.cacheTimestamps.clear();

    console.log("âœ… Vulnerability database updated");
  }

  getStats(): {
    cacheSize: number;
    sources: VulnerabilitySource[];
    lastUpdate: Date | null;
  } {
    return {
      cacheSize: this.cache.size,
      sources: this.sources,
      lastUpdate: null // Would track last successful update in production
    };
  }

  private loadSources(): void {
    this.sources = [
      {
        name: "OSV (Open Source Vulnerabilities)",
        url: "https://api.osv.dev",
        ecosystem: [NODE_PACKAGE_ECOSYSTEM, "pypi", "maven", "go", "cargo", "packagist", "rubygems"],
        enabled: this.isOSVEnabled()
      },
      {
        name: "GitHub Security Advisories",
        url: "https://api.github.com/advisories",
        ecosystem: [NODE_PACKAGE_ECOSYSTEM, "pypi", "maven", "go", "cargo", "packagist", "rubygems"],
        enabled: false // Would require GitHub token
      },
      {
        name: "Local Mock Database",
        url: "internal://mock",
        ecosystem: [NODE_PACKAGE_ECOSYSTEM, "pypi", "maven", "go", "cargo", "packagist", "rubygems"],
        enabled: true
      }
    ];
  }

  private async fetchOSVVulnerabilities(
    packageName: string,
    version: string,
    ecosystem: string
  ): Promise<Vulnerability[]> {
    const payload = {
      package: { name: packageName, ecosystem },
      version
    };

    const response = await this.httpPostJSON(
      "https://api.osv.dev/v1/query",
      payload,
      10000
    );

    return this.mapOSVResponse(packageName, version, response);
  }

  private async fetchOSVBatch(dependencies: DependencyInfo[]): Promise<Vulnerability[]> {
    const queries = dependencies.map(dep => ({
      package: { name: dep.name, ecosystem: dep.ecosystem },
      version: dep.version
    }));

    const payload = { queries };

    const response = await this.httpPostJSON(
      "https://api.osv.dev/v1/querybatch",
      payload,
      15000
    );

    const vulnerabilities: Vulnerability[] = [];

    if (response?.results && Array.isArray(response.results)) {
      for (let i = 0; i < dependencies.length; i++) {
        const dep = dependencies[i];
        const result = response.results[i];

        if (result?.vulns) {
          const vulns = this.mapOSVResponse(dep.name, dep.version, result);
          vulnerabilities.push(...vulns);
        }
      }
    }

    return vulnerabilities;
  }

  private mapOSVResponse(
    packageName: string,
    version: string,
    response: OSVResponse
  ): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    if (!response?.vulns || !Array.isArray(response.vulns)) {
      return vulnerabilities;
    }

    for (const vuln of response.vulns) {
      try {
        const vulnerability = this.mapOSVVulnerability(packageName, version, vuln);
        if (vulnerability) {
          vulnerabilities.push(vulnerability);
        }
      } catch (error) {
        console.warn(`Failed to map OSV vulnerability ${vuln.id}:`, error);
      }
    }

    return vulnerabilities;
  }

  private mapOSVVulnerability(
    packageName: string,
    version: string,
    vuln: OSVVulnerability
  ): Vulnerability | null {
    if (!vuln.id) {
      return null;
    }

    // Extract preferred vulnerability ID (CVE > GHSA > OSV ID)
    const aliases = vuln.aliases || [];
    const cveId = aliases.find(alias => /^CVE-\d{4}-\d{3,}$/i.test(alias));
    const ghsaId = aliases.find(alias => /^GHSA-/i.test(alias));
    const preferredId = cveId || ghsaId || vuln.id;

    // Extract severity
    let cvssScore = 0;
    let severity: SecuritySeverity = "medium";

    if (vuln.severity && Array.isArray(vuln.severity)) {
      for (const sev of vuln.severity) {
        if (typeof sev.score === "number") {
          cvssScore = Math.max(cvssScore, sev.score);
        } else if (typeof sev.score === "string") {
          const parsed = parseFloat(sev.score);
          if (!isNaN(parsed)) {
            cvssScore = Math.max(cvssScore, parsed);
          }
        }
      }
    }

    // Map CVSS score to severity
    if (cvssScore >= 9.0) severity = "critical";
    else if (cvssScore >= 7.0) severity = "high";
    else if (cvssScore >= 4.0) severity = "medium";
    else if (cvssScore > 0) severity = "low";
    else severity = "medium";

    // Check database_specific for additional severity info
    if (vuln.database_specific?.severity) {
      const dbSeverity = vuln.database_specific.severity.toLowerCase();
      const severityMap: Record<string, SecuritySeverity> = {
        critical: "critical",
        high: "high",
        moderate: "medium",
        medium: "medium",
        low: "low",
        info: "info"
      };
      if (severityMap[dbSeverity]) {
        severity = severityMap[dbSeverity];
      }
    }

    // Find fixed version
    let fixedVersion = "";
    if (vuln.affected) {
      for (const affected of vuln.affected) {
        if (affected.package?.name === packageName && affected.ranges) {
          for (const range of affected.ranges) {
            if (range.events) {
              for (const event of range.events) {
                if (event.fixed) {
                  fixedVersion = event.fixed;
                  break;
                }
              }
            }
          }
        }
      }
    }

    const vulnerability: Vulnerability = {
      id: `${packageName}_${vuln.id}`,
      type: "vulnerability",
      packageName,
      version,
      vulnerabilityId: preferredId,
      severity,
      description: vuln.summary || vuln.details || `Vulnerability in ${packageName}`,
      cvssScore,
      affectedVersions: "", // Would need to parse ranges
      fixedInVersion: fixedVersion,
      publishedAt: vuln.published ? new Date(vuln.published) : new Date(),
      lastUpdated: vuln.modified ? new Date(vuln.modified) : new Date(),
      exploitability: cvssScore >= 7.0 ? "high" : cvssScore >= 4.0 ? "medium" : "low",
      references: aliases,
      metadata: {
        source: "OSV",
        osvId: vuln.id,
        aliases,
        originalSeverity: vuln.database_specific?.severity
      }
    };

    return vulnerability;
  }

  private getMockVulnerabilities(packageName: string, version: string): Vulnerability[] {
    const mockVulns: Record<string, any[]> = {
      lodash: [
        {
          id: "CVE-2021-23337",
          severity: "high",
          description: "Prototype pollution in lodash",
          affectedVersions: "<4.17.12",
          fixedInVersion: "4.17.12",
          cvssScore: 7.5
        }
      ],
      express: [
        {
          id: "CVE-2019-5413",
          severity: "medium",
          description: "Memory exposure in express",
          affectedVersions: "<4.17.2",
          fixedInVersion: "4.17.2",
          cvssScore: 5.0
        }
      ],
      axios: [
        {
          id: "CVE-2020-28168",
          severity: "medium",
          description: "Server-side request forgery in axios",
          affectedVersions: "<0.21.1",
          fixedInVersion: "0.21.1",
          cvssScore: 6.1
        }
      ]
    };

    const packageVulns = mockVulns[packageName] || [];
    const vulnerabilities: Vulnerability[] = [];

    for (const vuln of packageVulns) {
      if (this.isVersionVulnerable(version, vuln.affectedVersions)) {
        vulnerabilities.push({
          id: `${packageName}_${vuln.id}`,
          type: "vulnerability",
          packageName,
          version,
          vulnerabilityId: vuln.id,
          severity: vuln.severity,
          description: vuln.description,
          cvssScore: vuln.cvssScore,
          affectedVersions: vuln.affectedVersions,
          fixedInVersion: vuln.fixedInVersion,
          publishedAt: new Date(),
          lastUpdated: new Date(),
          exploitability: vuln.cvssScore >= 7.0 ? "high" : "medium",
          metadata: {
            source: "Mock",
            isMock: true
          }
        });
      }
    }

    return vulnerabilities;
  }

  private isVersionVulnerable(version: string, affectedVersions: string): boolean {
    // Simplified version comparison for mock data
    // In production, would use proper semver comparison

    if (affectedVersions.startsWith("<")) {
      const targetVersion = affectedVersions.substring(1);
      return this.compareVersions(version, targetVersion) < 0;
    }

    if (affectedVersions.includes("-")) {
      const [min, max] = affectedVersions.split("-");
      return this.compareVersions(version, min) >= 0 &&
             this.compareVersions(version, max) <= 0;
    }

    return version === affectedVersions;
  }

  private compareVersions(version1: string, version2: string): number {
    const v1Parts = version1.replace(/[^\d.]/g, "").split(".").map(Number);
    const v2Parts = version2.replace(/[^\d.]/g, "").split(".").map(Number);

    const maxLength = Math.max(v1Parts.length, v2Parts.length);

    for (let i = 0; i < maxLength; i++) {
      const v1Part = v1Parts[i] || 0;
      const v2Part = v2Parts[i] || 0;

      if (v1Part < v2Part) return -1;
      if (v1Part > v2Part) return 1;
    }

    return 0;
  }

  private isCacheValid(cacheKey: string): boolean {
    if (!this.cache.has(cacheKey)) {
      return false;
    }

    const timestamp = this.cacheTimestamps.get(cacheKey);
    if (!timestamp) {
      return false;
    }

    return Date.now() - timestamp < this.CACHE_TTL;
  }

  private isOSVEnabled(): boolean {
    return (process.env.SECURITY_OSV_ENABLED || "true").toLowerCase() !== "false";
  }

  private async httpPostJSON(url: string, body: any, timeout: number): Promise<any> {
    try {
      // Use fetch if available (Node 18+)
      const globalThis = global as any;
      if (typeof globalThis.fetch === "function") {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), timeout);

        try {
          const response = await globalThis.fetch(url, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify(body),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          return await response.json();
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }
      }
    } catch (error) {
      console.warn("Fetch failed, falling back to https module:", error);
    }

    // Fallback to https module
    return new Promise((resolve, reject) => {
      try {
        const { request } = require("https");
        const { URL } = require("url");
        const parsedUrl = new URL(url);

        const req = request(
          {
            hostname: parsedUrl.hostname,
            path: parsedUrl.pathname + (parsedUrl.search || ""),
            method: "POST",
            headers: { "content-type": "application/json" },
            timeout
          },
          (res: any) => {
            const chunks: Buffer[] = [];
            res.on("data", (chunk: Buffer) => chunks.push(chunk));
            res.on("end", () => {
              try {
                const text = Buffer.concat(chunks).toString("utf-8");
                const data = JSON.parse(text);
                resolve(data);
              } catch (error) {
                reject(new Error(`Failed to parse JSON response: ${error}`));
              }
            });
          }
        );

        req.on("error", reject);
        req.on("timeout", () => {
          req.destroy();
          reject(new Error("Request timeout"));
        });

        req.write(JSON.stringify(body));
        req.end();
      } catch (error) {
        reject(error);
      }
    });
  }
}
