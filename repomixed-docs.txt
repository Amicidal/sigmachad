This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
Brainstorm.md
KnowledgeGraphDesign.md
MementoAPIDesign.md
MementoArchitecture.md
MementoReusableTools.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Brainstorm.md">
### Project Memento

    The goal of Memento is to create an agent-first MCP server for AI coding agents so they have full awareness of the changes they intend to make and have made. It builds a knowledge graph over the codebase and uses a vector index to prevent context drift and code quality issues. It acts as a validation gate to ensure quality and prevent current and future technical debt.  The development lifecycle should go from Docs -> Tests -> Implementation

### Problems to solve
    Pre-Tool
        - Agents tend to reimplement instead of reusing existing code.
        - Finding and selecting implementations via multi-hop grep wastes tokens and misses edge cases.
        - Incorrect API usage (wrong args/order, hallucinated options).
        - Little consideration for current architecture/policies due to massive token wastage of searching every time. 

    Post-Tool
        - Codebase state changes make docs/imports stale; cascades across files.
        - Partial updates leave inconsistencies that aren’t caught.
        - No validation via static tools or agent driven self-reflection that changes align with architecture/policies.
        - Coding Agents can be incredibly deceptive in that they constantly create mocks or simplified versions of intended sophisticated implementations that breaks everything. 
        
   
### Architecture
    Language: TypeScript (Node.js)
    Graph Database: FalkorDB
    Vector Database: Qdrant
    Orchestration: Docker Compose

### Lifecycle Gates
    Overview: Docs -> Tests -> Implementation -> Validation -> Impact -> Commit
    Docs
        - Spec must include title, goals, acceptance criteria.
        - Stored with ID; linked to all subsequent changes.
    Tests
        - Generate or update tests from the spec; initially failing is acceptable.
        - Enforce minimum changed-lines coverage threshold (configurable).
    Implementation
        - Propose diffs only after spec and tests exist.
        - Prefer reuse via graph and examples; block stubs/simplified mocks.
        - Respect architecture and policy constraints.
    Validation
        - TypeScript type-check, ESLint, security lint.
        - Architecture policy engine (layering, banned imports/deps).
        - All tests must pass; coverage threshold must be met.
    Impact
        - Update knowledge graph and vector index after accepted diffs.
        - Detect stale imports/exports/re-exports and propose follow-up edits.
    Commit
        - Create branch/commit/PR with links to spec, tests, and validation report.

### Graph Schema
    Entities
        - File, Directory, Module/Package, Symbol, Function, Class, Interface, TypeAlias, Test, Doc
    Edges
        - imports, exports, re-exports, defines, declares, calls, references, implements, extends, tested-by, belongs-to
    Properties
        - path, hash, language, signature, docstring, lastModified, owningModule, coverage

### Tooling API
    Exposed as an MCP server (Claude Code) and mirrored via HTTP function-calls (OpenAI).
    Tools
        - design.create_spec: Create/validate a feature spec; returns spec ID and acceptance criteria.
        - tests.plan_and_generate: Generate/update tests for a spec; returns changed files.
        - graph.search: Path/usage queries over symbols/APIs; finds reuse candidates.
        - graph.examples: Canonical usages and tests for an API, with signatures and arg order.
        - code.propose_diff: Stage edits as diffs; returns affected graph nodes.
        - validate.run: Run type-check, lint, policy checks, security lint, tests, coverage.
        - impact.analyze: Cascade analysis for stale imports/exports; propose consistency edits.
        - vdb.search: Semantic retrieval joined to graph nodes.
        - scm.commit_pr: Create branch/commit/PR with links to spec/tests/validation.

### Validation Policy
    Configuration file: memento.yaml
        - layers: allowed import directions; banned cross-layer imports.
        - bannedDependencies: disallowed packages or paths.
        - coverageMin: overall and changed-lines thresholds.
        - forbiddenPatterns: e.g., TODO returns, throw new Error('Not Implemented').
        - security: basic dependency and code-level checks.
        - docTemplate/testTemplate: shared templates for spec and test generation.
    Enforcement
        - Block direct file edits unless prior gates pass.
        - Reject diffs that reduce coverage below threshold or violate architecture.

### Integration Guides
    Claude Code (MCP)
        - Register Memento as an MCP server; tools listed above.
        - Enforce step order in system prompt; refuse direct edits until spec+tests exist.
        - On violations, reply with next required tool invocation.
    OpenAI Tools (Assistants)
        - Mirror MCP tools via HTTP function-calls; identical names/schemas.
        - Use tool-calling flow to enforce gates; server rejects out-of-order actions.
        - Return actionable errors pointing to the next required step.

### Implementation Notes
    Indexing
        - TypeScript-first via ts-morph for precise symbols/types.
        - Polyglot path via tree-sitter/LSP adapters.
    Storage
        - Graph: FalkorDB; Vector: Qdrant with metadata keyed to graph node IDs.
    Ops
        - Docker Compose services: memento, falkordb, qdrant.
        - File watcher to resync graph/vector on file changes.
        - CLI: memento validate, memento impact.

### Key Behaviors and Anti-Deception
    Pre-Tool
        - Favor reuse with graph.search and graph.examples; prevent hallucinated options via signature checks.
        - Replace multi-hop grep with path queries through the graph.
    Post-Tool
        - Auto graph/vector sync on accepted diffs.
        - Consistency sweep for stale imports/exports; propose follow-ups via impact.analyze.
    Anti-Deception Heuristics
        - Detect trivial or stub implementations and block merging.
        - Require changed-lines coverage and diff-linked tests.
</file>

<file path="KnowledgeGraphDesign.md">
# Knowledge Graph Design for Memento

## Overview

This document outlines the comprehensive knowledge graph schema for the Memento system, designed to provide full awareness of codebase changes and prevent context drift in AI coding agents.

## Core Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Codebase      │    │  Knowledge      │    │   Vector        │
│   Files         │────│   Graph         │────│   Index         │
│                 │    │  (FalkorDB)     │    │  (Qdrant)       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                              ▼
                       ┌─────────────────┐
                       │   Validation    │
                       │   Engine        │
                       └─────────────────┘
```

## Node Types (Entities)

### 1. CodebaseEntity
**Base node for all codebase elements**
```
{
  id: string (UUID)
  path: string (relative to project root)
  hash: string (content hash)
  language: string (typescript, javascript, etc.)
  lastModified: timestamp
  created: timestamp
  metadata: object (additional properties)
}
```

### 2. File
**Represents source files**
```
{
  ...CodebaseEntity,
  type: "file"
  extension: string
  size: number (bytes)
  lines: number
  isTest: boolean
  isConfig: boolean
  dependencies: string[] (external packages)
}
```

### 3. Directory
**Represents directory structure**
```
{
  ...CodebaseEntity,
  type: "directory"
  children: string[] (file/directory IDs)
  depth: number (from root)
}
```

### 4. Module
**Represents logical modules/packages**
```
{
  ...CodebaseEntity,
  type: "module"
  name: string
  version: string
  packageJson: object
  entryPoint: string (main file path)
}
```

### 5. Symbol
**Base for code symbols (functions, classes, etc.)**
```
{
  ...CodebaseEntity,
  type: "symbol"
  name: string
  kind: string (function, class, interface, etc.)
  signature: string (full type signature)
  docstring: string
  visibility: string (public, private, protected)
  isExported: boolean
  isDeprecated: boolean
}
```

### 6. Function
**Function definitions**
```
{
  ...Symbol,
  kind: "function"
  parameters: object[] (name, type, defaultValue, optional)
  returnType: string
  isAsync: boolean
  isGenerator: boolean
  complexity: number (cyclomatic complexity)
  calls: string[] (function IDs it calls)
}
```

### 7. Class
**Class definitions**
```
{
  ...Symbol,
  kind: "class"
  extends: string[] (class IDs)
  implements: string[] (interface IDs)
  methods: string[] (method IDs)
  properties: string[] (property IDs)
  isAbstract: boolean
}
```

### 8. Interface
**Interface definitions**
```
{
  ...Symbol,
  kind: "interface"
  extends: string[] (interface IDs)
  methods: string[] (method signatures)
  properties: string[] (property definitions)
}
```

### 9. TypeAlias
**Type alias definitions**
```
{
  ...Symbol,
  kind: "typeAlias"
  aliasedType: string
  isUnion: boolean
  isIntersection: boolean
}
```

### 10. Test
**Test entities**
```
{
  ...CodebaseEntity,
  type: "test"
  testType: string (unit, integration, e2e)
  targetSymbol: string (symbol ID being tested)
  framework: string (jest, vitest, etc.)
  coverage: object (lines, branches, functions)
}
```

### 11. Spec
**Feature specifications**
```
{
  ...CodebaseEntity,
  type: "spec"
  title: string
  description: string
  acceptanceCriteria: string[]
  status: string (draft, approved, implemented)
  priority: string (low, medium, high)
  assignee: string
  created: timestamp
  updated: timestamp
}
```

### 12. Change
**Tracks changes to codebase entities**
```
{
  id: string (UUID)
  type: "change"
  changeType: string (create, update, delete, rename, move)
  entityType: string (file, symbol, spec, etc.)
  entityId: string (ID of entity that changed)
  timestamp: timestamp
  author: string
  commitHash: string (optional)
  diff: string (change details)
  previousState: object (entity state before change)
  newState: object (entity state after change)
  sessionId: string (links to AI agent session)
  specId: string (optional, links to related spec)
}
```

### 13. Session
**Tracks AI agent interaction sessions**
```
{
  id: string (UUID)
  type: "session"
  startTime: timestamp
  endTime: timestamp
  agentType: string (claude, gpt, etc.)
  userId: string
  changes: string[] (change IDs from this session)
  specs: string[] (spec IDs created in this session)
  status: string (active, completed, failed)
  metadata: object (session context and parameters)
}
```

## Relationship Types (Edges)

### Base Relationship Properties
All relationships include:
```
{
  created: timestamp
  lastModified: timestamp
  version: number (incrementing version for relationship changes)
  metadata: object (additional relationship-specific data)
}
```

### Structural Relationships
- `BELONGS_TO`: File/Directory → Directory (hierarchy)
- `CONTAINS`: Directory → File/Directory
- `DEFINES`: File → Symbol (symbol defined in file)
- `EXPORTS`: File → Symbol (symbol exported from file)
- `IMPORTS`: File → Symbol (symbol imported by file)

### Code Relationships
- `CALLS`: Function → Function (function calls another)
- `REFERENCES`: Symbol → Symbol (symbol references another)
- `IMPLEMENTS`: Class → Interface (class implements interface)
- `EXTENDS`: Class → Class, Interface → Interface (inheritance)
- `DEPENDS_ON`: Symbol → Symbol (dependency relationship)
- `USES`: Symbol → Symbol (usage relationship)

### Test Relationships
- `TESTS`: Test → Symbol (test covers symbol)
- `VALIDATES`: Test → Spec (test validates spec criteria)
- `LOCATED_IN`: Test → File (test file location)

### Spec Relationships
- `REQUIRES`: Spec → Symbol (spec requires symbol implementation)
- `IMPACTS`: Spec → File/Directory (files impacted by spec)
- `LINKED_TO`: Spec → Spec (related specifications)

### Temporal Relationships
- `PREVIOUS_VERSION`: Entity → Entity (links to previous version of same entity)
- `CHANGED_AT`: Entity → Timestamp (tracks when entity changed)
- `MODIFIED_BY`: Entity → Change (links entity to change that modified it)
- `CREATED_IN`: Entity → Commit/Session (links entity to creation context)

### Change Tracking Relationships
- `INTRODUCED_IN`: Entity → Change (when entity was first introduced)
- `MODIFIED_IN`: Entity → Change (all changes that modified entity)
- `REMOVED_IN`: Entity → Change (when entity was removed/deleted)

## Graph Constraints and Indexes

### Unique Constraints
- File.path: unique file paths
- Symbol.name + Symbol.file: unique symbol names within files
- Spec.title: unique spec titles
- Module.name: unique module names

### Indexes
- File.path: for fast file lookups
- Symbol.name: for symbol name searches
- Symbol.kind: for filtering by symbol type
- Spec.status: for filtering specs by status

### Temporal Indexes
- Entity.lastModified: for recent changes queries
- Entity.created: for creation time queries
- Change.timestamp: for change history queries
- Session.startTime/endTime: for session queries
- Relationship.created: for relationship creation queries
- Relationship.lastModified: for relationship change queries

### Composite Indexes
- (entityType + timestamp): for entity type change history
- (sessionId + timestamp): for session activity
- (specId + timestamp): for spec-related changes

## Vector Database Integration

### Embedding Strategy
- **Code Embeddings**: Functions, classes, interfaces
- **Documentation Embeddings**: Specs, comments, docstrings
- **Test Embeddings**: Test cases and assertions

### Metadata Mapping
```typescript
interface VectorMetadata {
  nodeId: string;           // Graph node ID
  nodeType: string;         // Entity type
  path: string;             // File path
  symbolName?: string;      // Symbol name if applicable
  symbolKind?: string;      // Symbol type if applicable
  language: string;         // Programming language
  created: timestamp;       // Creation time
  lastModified: timestamp;  // Last modification time
  version: number;          // Entity version
  changeFrequency: number;  // How often entity changes
  sessionId?: string;       // Last modifying session
  author?: string;          // Last modifying author
  tags: string[];           // Additional tags
}
```

### Temporal Search Patterns
- **Recent Code Search**: Find recently modified similar code
- **Temporal Code Similarity**: Compare code at different points in time
- **Change-aware Search**: Weight results by recency and change frequency
- **Session Context Search**: Find code modified in similar sessions

### Search Patterns
- **Semantic Code Search**: Find similar functions/classes
- **API Usage Examples**: Find usage patterns for symbols
- **Test Case Retrieval**: Find relevant tests for symbols
- **Spec Matching**: Find related specifications

## Query Patterns

### 1. Symbol Usage Analysis
```
MATCH (s:Symbol {name: $symbolName})
OPTIONAL MATCH (s)<-[:CALLS|REFERENCES|USES]-(caller:Symbol)
OPTIONAL MATCH (s)-[:CALLS|REFERENCES|USES]->(callee:Symbol)
OPTIONAL MATCH (s)<-[:TESTS]-(t:Test)
RETURN s, collect(caller) as callers, collect(callee) as callees, collect(t) as tests
```

### 2. File Dependency Graph
```
MATCH (f:File {path: $filePath})
OPTIONAL MATCH (f)-[:IMPORTS]->(s:Symbol)<-[:EXPORTS]-(ef:File)
OPTIONAL MATCH (f)-[:EXPORTS]->(es:Symbol)<-[:IMPORTS]-(if:File)
RETURN f, collect(DISTINCT ef) as importedFrom, collect(DISTINCT if) as importedBy
```

### 3. Impact Analysis
```
MATCH (s:Symbol {id: $symbolId})
MATCH (s)<-[:CALLS|REFERENCES|USES|IMPLEMENTS|EXTENDS*1..3]-(dependent:Symbol)
MATCH (dependent)-[:DEFINES]->(f:File)
RETURN DISTINCT f.path as affectedFiles, dependent.name as dependentSymbols
```

### 4. Test Coverage Analysis
```
MATCH (spec:Spec {id: $specId})
OPTIONAL MATCH (spec)<-[:VALIDATES]-(t:Test)
OPTIONAL MATCH (t)-[:TESTS]->(s:Symbol)
OPTIONAL MATCH (s)-[:DEFINES]->(f:File)
RETURN spec, collect(t) as tests, collect(DISTINCT s) as symbols, collect(DISTINCT f) as files
```

## Temporal Query Patterns

### 1. Recent Changes Query
**Find all entities modified within a time window**
```
MATCH (e:CodebaseEntity)
WHERE e.lastModified >= $startTime AND e.lastModified <= $endTime
RETURN e.path, e.type, e.lastModified, e.created
ORDER BY e.lastModified DESC
```

### 2. Entity Evolution History
**Track how a specific entity has changed over time**
```
MATCH (current:File {path: $filePath})
OPTIONAL MATCH (current)<-[:PREVIOUS_VERSION*]-(previous:File)
OPTIONAL MATCH (current)-[:MODIFIED_IN]->(changes:Change)
RETURN current, collect(previous) as previousVersions,
       collect(changes {.*, .timestamp}) as changeHistory
ORDER BY changes.timestamp DESC
```

### 3. Session Activity Analysis
**Find all changes made in a specific AI agent session**
```
MATCH (session:Session {id: $sessionId})
OPTIONAL MATCH (session)-[:CONTAINS]->(changes:Change)
OPTIONAL MATCH (changes)-[:AFFECTS]->(entities)
RETURN session, collect(changes) as changes,
       collect(DISTINCT entities) as affectedEntities
```

### 4. Temporal Impact Analysis
**Find entities affected by changes within a time window**
```
MATCH (change:Change)
WHERE change.timestamp >= $startTime AND change.timestamp <= $endTime
MATCH (change)-[:AFFECTS]->(affected:CodebaseEntity)
OPTIONAL MATCH (affected)-[:DEPENDS_ON|USES|CALLS*1..2]->(downstream:CodebaseEntity)
RETURN change, collect(DISTINCT affected) as directlyAffected,
       collect(DISTINCT downstream) as indirectlyAffected
```

### 5. Cascading Change Detection
**Detect breaking changes and their downstream impact**
```
MATCH (changed:Function {name: $functionName})
WHERE changed.lastModified >= $changeTime
// Find all direct callers
MATCH (caller:Function)-[:CALLS]->(changed)
// Find files that import and use this function
MATCH (caller)-[:DEFINES]->(file:File)
MATCH (file)-[:IMPORTS]->(changed)
// Find indirect dependents (functions that call the callers)
OPTIONAL MATCH (indirect:Function)-[:CALLS*1..3]->(caller)
// Find files containing indirect dependents
OPTIONAL MATCH (indirect)-[:DEFINES]->(indirectFile:File)
RETURN changed.name as changedFunction,
       collect(DISTINCT caller.name) as directCallers,
       collect(DISTINCT file.path) as directlyAffectedFiles,
       collect(DISTINCT indirect.name) as indirectCallers,
       collect(DISTINCT indirectFile.path) as indirectlyAffectedFiles
```

### 6. Signature Change Impact
**Analyze impact of function signature changes**
```
MATCH (func:Function {name: $functionName})
MATCH (func)-[:DEFINES]->(definingFile:File)
// Find all files that import this function
MATCH (importingFile:File)-[:IMPORTS]->(func)
// Find all usage sites within those files
MATCH (usage:Function)-[:DEFINES]->(importingFile)
WHERE usage.signature =~ ".*" + func.name + ".*"
// Check if usage matches current function signature
MATCH (func)-[:MODIFIED_IN]->(changes:Change)
WHERE changes.changeType = "signature_change"
RETURN importingFile.path as affectedFile,
       usage.name as usingFunction,
       func.signature as newSignature,
       changes.previousState.signature as oldSignature,
       changes.timestamp as changeTime
```

### 7. Breaking Change Propagation
**Find complete propagation path of breaking changes**
```
MATCH (breakingChange:Change {changeType: "breaking"})
WHERE breakingChange.timestamp >= $sinceTime
MATCH (breakingChange)-[:AFFECTS]->(primaryEntity:Symbol)
// Find cascading dependencies
MATCH path = (primaryEntity)-[:CALLS|REFERENCES|USES|IMPLEMENTS|EXTENDS*1..5]-(dependent:Symbol)
WHERE ALL(rel IN relationships(path) WHERE rel.created < breakingChange.timestamp)
MATCH (dependent)-[:DEFINES]->(affectedFile:File)
// Group by distance from breaking change
RETURN affectedFile.path,
       length(path) as distanceFromChange,
       collect(DISTINCT dependent.name) as affectedSymbols,
       breakingChange.changeType,
       breakingChange.timestamp
ORDER BY distanceFromChange, affectedFile.path
```

### 8. Change Pattern Analysis
**Analyze change patterns for a specific entity type**
```
MATCH (entity:CodebaseEntity)
WHERE entity.type = $entityType
MATCH (entity)-[:MODIFIED_IN]->(changes:Change)
RETURN entity.path, count(changes) as changeCount,
       min(changes.timestamp) as firstModified,
       max(changes.timestamp) as lastModified,
       collect(changes.changeType) as changeTypes
ORDER BY changeCount DESC
```

### 9. Relationship Evolution
**Track how relationships between entities have evolved**
```
MATCH (a:Symbol {name: $symbolA})-[r:CALLS|USES|REFERENCES]-(b:Symbol {name: $symbolB})
WHERE r.created >= $startTime
RETURN a.name, b.name, type(r) as relationshipType,
       r.created, r.lastModified, r.version
ORDER BY r.lastModified DESC
```

### 10. Codebase Age Analysis
**Analyze the age distribution of codebase entities**
```
MATCH (e:CodebaseEntity)
RETURN e.type,
       count(e) as totalCount,
       min(e.created) as oldest,
       max(e.created) as newest,
       avg(duration.between(e.created, datetime()).days) as avgAgeDays
ORDER BY avgAgeDays DESC
```

### 11. Recent Activity by Agent
**Find recent activity by specific AI agent type**
```
MATCH (session:Session {agentType: $agentType})
WHERE session.startTime >= $startTime
OPTIONAL MATCH (session)-[:CONTAINS]->(changes:Change)
OPTIONAL MATCH (changes)-[:AFFECTS]->(entities:CodebaseEntity)
RETURN session, count(changes) as changeCount,
       collect(DISTINCT entities.type) as affectedEntityTypes,
       collect(DISTINCT changes.changeType) as changeTypes
ORDER BY session.startTime DESC
```

## Lifecycle Integration

### 1. Spec Creation Phase
- Create Spec node
- Link to affected files/symbols via `IMPACTS` relationships
- Generate initial vector embeddings

### 2. Test Generation Phase
- Create/update Test nodes
- Link tests to specs via `VALIDATES`
- Link tests to symbols via `TESTS`
- Update vector index with test embeddings

### 3. Implementation Phase
- Update/create Symbol nodes
- Create relationships (`CALLS`, `REFERENCES`, `IMPLEMENTS`, etc.)
- Update File nodes with new hashes
- Refresh vector embeddings

### 4. Validation Phase
- Query graph for dependency analysis
- Check architectural constraints
- Verify test coverage via graph traversals

### 5. Impact Analysis Phase
- Traverse dependency graph for cascading effects
- Identify stale imports/exports
- Propose follow-up changes

## Anti-Deception Mechanisms

### 1. Implementation Quality Checks
- Detect stub implementations via complexity metrics
- Validate against forbidden patterns
- Check for proper error handling

### 2. Architecture Compliance
- Enforce layer boundaries via graph queries
- Block banned dependency imports
- Verify proper abstraction usage

### 3. Coverage Validation
- Track test-to-code relationships
- Enforce coverage thresholds
- Detect uncovered code paths

## Synchronization Mechanisms

### File System Watcher
**Real-time synchronization with filesystem changes**
```
Event Types:
- File Created/Modified/Deleted
- Directory Created/Deleted
- Git Operations (commit, branch switch, merge)

Watcher Implementation:
- Node.js chokidar for cross-platform file watching
- Debounced events (500ms) to handle rapid changes
- Ignore patterns: node_modules/**, .git/**, *.log, build/**, dist/**
- Queue-based processing to prevent overwhelming the system
```

### Change Detection Strategy
**Incremental vs Full Synchronization**

#### Incremental Sync (Real-time)
```typescript
interface FileChange {
  path: string;
  type: 'create' | 'modify' | 'delete' | 'rename';
  oldPath?: string;
  mtime: Date;
  size: number;
  hash: string;
}

interface SyncContext {
  change: FileChange;
  affectedNodes: string[]; // Graph node IDs
  requiresFullReindex: boolean;
  priority: 'high' | 'medium' | 'low';
}
```

**Change Classification:**
- **High Priority**: Core files (.ts, .js, package.json)
- **Medium Priority**: Config files, documentation
- **Low Priority**: Generated files, logs

#### Full Sync (Scheduled/Batch)
- Weekly full re-indexing
- After major refactors or merges
- On-demand via CLI: `memento sync --full`

### Graph Update Process

#### 1. Change Ingestion
```
File Change Detected → Queue → Prioritize → Process
                                      ↓
                              Create Change Node
                                      ↓
                           Update Affected Entities
                                      ↓
                        Update Relationships
                                      ↓
                     Update Vector Embeddings
                                      ↓
                   Validate & Cache Results
```

#### 2. Entity Updates
```typescript
async function updateEntity(change: FileChange): Promise<void> {
  // 1. Parse file with ts-morph/tree-sitter
  const ast = await parseFile(change.path);

  // 2. Extract symbols and relationships
  const entities = extractEntities(ast);
  const relationships = extractRelationships(ast);

  // 3. Compare with existing graph state
  const diff = await computeGraphDiff(change.path, entities, relationships);

  // 4. Apply changes transactionally
  await applyGraphChanges(diff);

  // 5. Update vector embeddings
  await updateEmbeddings(diff.modifiedEntities);

  // 6. Trigger impact analysis
  await analyzeImpact(diff);
}
```

#### 3. Relationship Synchronization
**Bidirectional Relationship Updates:**
- **Forward**: When A changes, update A→B relationships
- **Reverse**: When A changes, update B→A relationships (imports, references)
- **Cascade**: When A changes, check if B→C relationships need updates

**Relationship Types Requiring Sync:**
- CALLS: Function call sites
- REFERENCES: Symbol references
- IMPORTS/EXPORTS: Module dependencies
- IMPLEMENTS/EXTENDS: Inheritance chains
- TESTS: Test-to-code relationships

### Vector Database Synchronization

#### Embedding Update Strategy
```typescript
interface EmbeddingUpdate {
  nodeId: string;
  content: string;
  metadata: VectorMetadata;
  operation: 'create' | 'update' | 'delete';
  priority: number;
}

Batch Processing:
- Group by priority and operation type
- Process high-priority updates immediately
- Batch low-priority updates (100 items/batch)
- Retry failed updates with exponential backoff
```

#### Content Extraction for Embeddings
- **Functions**: Full function signature + docstring + body summary
- **Classes**: Class definition + method signatures + properties
- **Interfaces**: Interface definition + method signatures
- **Files**: Import statements + key function signatures
- **Tests**: Test descriptions + assertions

### Synchronization Triggers

#### Automatic Triggers
- **File System Events**: Real-time via file watcher
- **Git Operations**: Post-commit, post-merge hooks
- **IDE Actions**: Save events, refactor operations
- **CI/CD Pipeline**: Post-deployment sync

#### Manual Triggers
```bash
# Full sync
memento sync --full

# Sync specific files
memento sync src/components/Button.tsx src/utils/helpers.ts

# Sync by pattern
memento sync --pattern "src/**/*.ts"

# Force re-index vector embeddings
memento sync --embeddings

# Dry run to see what would change
memento sync --dry-run
```

### Conflict Resolution

#### Concurrent Changes
**Optimistic Locking:**
- Each entity has version number
- Changes include expected version
- Conflicts detected and resolved via merge strategies

**Merge Strategies:**
- **Last Write Wins**: For simple metadata updates
- **Manual Resolution**: For conflicting code changes
- **Version Branching**: Create parallel versions for complex conflicts

#### Stale Data Detection
```typescript
interface StaleCheck {
  entityId: string;
  graphVersion: number;
  fileVersion: number;
  lastSync: Date;
  isStale: boolean;
}

// Check staleness every 5 minutes
setInterval(async () => {
  const staleEntities = await findStaleEntities();
  for (const entity of staleEntities) {
    await queueResync(entity);
  }
}, 5 * 60 * 1000);
```

### Performance Optimizations

#### Graph Database
- Use appropriate indexes for common query patterns
- Implement graph partitioning for large codebases
- Cache frequently accessed subgraphs
- Connection pooling for concurrent operations

#### Vector Database
- Batch embedding updates (50-100 items per batch)
- Use approximate nearest neighbor search for performance
- Implement metadata filtering for faster retrieval
- Cache frequently accessed embeddings

#### Caching Strategy
- Cache graph queries for recent changes (TTL: 10 minutes)
- Store computed impact analyses (TTL: 1 hour)
- Cache validation results (TTL: 30 minutes)
- Invalidate caches on related changes

### Monitoring and Observability

#### Synchronization Metrics
- Sync latency (file change to graph update)
- Queue depth and processing rate
- Error rates by sync type
- Vector embedding update success rate

#### Health Checks
- File watcher connectivity
- Graph database responsiveness
- Vector database synchronization status
- Queue processing health

#### Alerts
- Sync failures > 5% error rate
- Queue depth > 1000 items
- Sync latency > 30 seconds
- Vector embedding failures

### Recovery Mechanisms

#### Automatic Recovery
- Failed sync retries (3 attempts with backoff)
- Partial sync recovery (resume from last successful point)
- Database connection recovery with circuit breaker

#### Manual Recovery
```bash
# Reset sync state
memento sync --reset

# Rebuild from scratch
memento sync --rebuild

# Validate sync consistency
memento sync --validate
```

### Integration Points

#### Development Workflow Integration
- **Pre-commit hooks**: Validate sync state before commits
- **IDE plugins**: Real-time sync status in editor
- **CI/CD integration**: Sync validation in pipelines
- **Git integration**: Sync on branch switches and merges

#### External System Integration
- **Version Control**: Git hooks for sync triggers
- **CI/CD**: Pipeline steps for sync validation
- **Monitoring**: Metrics export to external systems
- **Backup**: Sync state included in backups

## Final System Architecture

### Complete Synchronization Flow
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   File System   │────│  File Watcher   │────│   Queue System  │
│   Changes       │    │   (chokidar)    │    │   (Priority)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                        │                        │
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Change Parser  │────│ Graph Database │────│Vector Database │
│ (ts-morph/tree- │    │  (FalkorDB)    │    │   (Qdrant)     │
│    sitter)      │    │                 │    │                │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                        │                        │
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Impact Analysis │────│   Validation    │────│   Caching      │
│                 │    │   Engine        │    │   Layer        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Synchronization Performance Targets
- **File Change Latency**: < 2 seconds from file save to graph update
- **Query Performance**: < 100ms for common graph queries
- **Vector Search**: < 50ms for semantic searches
- **Throughput**: 100+ file changes per minute
- **Reliability**: 99.9% sync success rate

### Disaster Recovery
- **Point-in-time Recovery**: Restore to any previous state
- **Incremental Backups**: Daily graph snapshots
- **Cross-region Replication**: Multi-zone database setup
- **Automated Failover**: Switch to backup systems automatically

## Enhanced Capabilities Integration

### Documentation-Centric Semantic Integration

#### Architecture Integration
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Code Parser   │────│   Doc Parser    │────│ Knowledge Graph │
│  (ts-morph)     │    │ (Markdown, etc) │    │   (FalkorDB)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Documentation   │────│   LLM Engine    │────│ Semantic Links  │
│   Extraction    │    │ (Optional)      │    │ & Clustering    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

#### Documentation Node Types

##### DocumentationNode
**Represents documentation files and their content**
```
{
  id: string (UUID)
  type: "documentation"
  filePath: string
  title: string
  content: string (full text content)
  docType: string ("readme", "api-docs", "design-doc", "architecture", "user-guide")
  lastModified: timestamp
  lastIndexed: timestamp
  businessDomains: string[] (extracted business domains)
  stakeholders: string[] (mentioned stakeholders)
  technologies: string[] (mentioned technologies/frameworks)
  status: string ("active", "deprecated", "draft")
}
```

##### BusinessDomain
**Represents business domains extracted from documentation**
```
{
  id: string (UUID)
  type: "businessDomain"
  name: string
  description: string
  parentDomain?: string (for hierarchical domains)
  criticality: string ("core", "supporting", "utility")
  stakeholders: string[] ("users", "admins", "developers", "business")
  keyProcesses: string[] (business processes this domain supports)
  extractedFrom: string[] (documentation source IDs)
}
```

##### SemanticCluster
**Groups related code entities by business functionality**
```
{
  id: string (UUID)
  type: "semanticCluster"
  name: string
  description: string
  businessDomainId: string
  clusterType: string ("feature", "module", "capability", "service")
  cohesionScore: number (0-1, how tightly related entities are)
  lastAnalyzed: timestamp
  memberEntities: string[] (IDs of entities in this cluster)
}
```

#### Documentation Relationship Types

##### DESCRIBES_DOMAIN
- **Source**: DocumentationNode → BusinessDomain
- **Properties**: confidence, extraction method, last validated

##### BELONGS_TO_DOMAIN
- **Source**: CodebaseEntity → BusinessDomain
- **Properties**: strength, inferred vs explicit, last validated

##### DOCUMENTED_BY
- **Source**: CodebaseEntity → DocumentationNode
- **Properties**: documentation quality, coverage completeness, last sync

##### CLUSTER_MEMBER
- **Source**: CodebaseEntity → SemanticCluster
- **Properties**: membership strength, role in cluster, join date

##### DOMAIN_RELATED
- **Source**: BusinessDomain → BusinessDomain
- **Properties**: relationship type, strength, business context

#### Documentation Processing Pipeline

**1. Documentation Discovery:**
```typescript
async function discoverDocumentation(rootPath: string): Promise<DocumentationNode[]> {
  const patterns = [
    'README.md', 'docs/**/*.md', 'api/**/*.md',
    'architecture/**/*.md', 'design/**/*.md'
  ];

  const docs: DocumentationNode[] = [];
  for (const pattern of patterns) {
    const files = await glob(pattern, { cwd: rootPath });
    for (const file of files) {
      const content = await readFile(file);
      const doc = await parseDocumentation(file, content);
      docs.push(doc);
    }
  }

  return docs;
}
```

**2. Domain Extraction (Optional LLM Enhancement):**
```typescript
async function extractBusinessDomains(doc: DocumentationNode): Promise<BusinessDomain[]> {
  // Primary: Extract from explicit sections and patterns
  const explicitDomains = extractExplicitDomains(doc.content);

  // Secondary: LLM-assisted extraction for complex docs
  if (needsLLM(doc)) {
    const llmDomains = await llm.extract(`
      Extract business domains from this documentation:
      ${doc.content}

      Focus on:
      1. Business capabilities described
      2. User roles and stakeholders
      3. Business processes mentioned
      4. Domain boundaries and relationships
    `);
    return [...explicitDomains, ...llmDomains];
  }

  return explicitDomains;
}
```

**3. Semantic Clustering:**
```typescript
async function createSemanticClusters(
  entities: CodebaseEntity[],
  domains: BusinessDomain[]
): Promise<SemanticCluster[]> {
  const clusters: SemanticCluster[] = [];

  // Group entities by shared imports, calls, and domains
  const entityGroups = groupBySharedRelationships(entities);

  for (const group of entityGroups) {
    const cluster = new SemanticCluster({
      name: inferClusterName(group),
      description: inferClusterDescription(group, domains),
      businessDomainId: findRelevantDomain(group, domains),
      memberEntities: group.map(e => e.id),
      cohesionScore: calculateCohesion(group)
    });
    clusters.push(cluster);
  }

  return clusters;
}
```

#### Documentation Synchronization

**1. Documentation Change Detection:**
```typescript
async function syncDocumentation() {
  const docs = await discoverDocumentation(projectRoot);

  for (const doc of docs) {
    const existing = await findDocumentationByPath(doc.filePath);

    if (!existing || existing.lastModified < doc.lastModified) {
      await updateDocumentation(doc);
      await updateDomainRelationships(doc);
      await updateSemanticClusters(doc);
    }
  }
}
```

**2. Cluster Maintenance:**
```typescript
async function maintainClusters() {
  // Remove stale clusters
  const staleClusters = await findClustersWithLowCohesion();
  for (const cluster of staleClusters) {
    await dissolveCluster(cluster);
  }

  // Merge overlapping clusters
  const overlapping = await findOverlappingClusters();
  for (const pair of overlapping) {
    await mergeClusters(pair.cluster1, pair.cluster2);
  }

  // Update cluster descriptions
  const clusters = await getAllClusters();
  for (const cluster of clusters) {
    await updateClusterDescription(cluster);
  }
}
```

#### Query Patterns for Documentation-Centric Analysis

**Find code by business domain:**
```cypher
MATCH (d:BusinessDomain {name: $domainName})
MATCH (c:CodebaseEntity)-[:BELONGS_TO_DOMAIN]->(d)
OPTIONAL MATCH (c)-[:CLUSTER_MEMBER]->(sc:SemanticCluster)
RETURN c, sc.name as clusterName, sc.description as clusterDescription
ORDER BY c.path
```

**Get documentation for a code entity:**
```cypher
MATCH (c:CodebaseEntity {id: $entityId})
MATCH (c)-[:DOCUMENTED_BY]->(doc:DocumentationNode)
MATCH (doc)-[:DESCRIBES_DOMAIN]->(d:BusinessDomain)
RETURN doc.title, doc.content, d.name as businessDomain
ORDER BY doc.lastModified DESC
```

**Find clusters by business capability:**
```cypher
MATCH (d:BusinessDomain)-[:DOMAIN_RELATED*0..2]->(related:BusinessDomain)
WHERE d.name = $capabilityName
MATCH (sc:SemanticCluster)-[:BELONGS_TO_DOMAIN]->(related)
MATCH (c:CodebaseEntity)-[:CLUSTER_MEMBER]->(sc)
RETURN sc.name, sc.description, collect(c.path) as entities
ORDER BY sc.cohesionScore DESC
```

**Business impact analysis:**
```cypher
MATCH (d:BusinessDomain {name: $domainName})
MATCH (d)<-[:BELONGS_TO_DOMAIN]-(c:CodebaseEntity)
MATCH (c)-[:MODIFIED_IN]->(changes:Change)
WHERE changes.timestamp >= $sinceTime
RETURN c.path, count(changes) as changeCount,
       collect(changes.changeType) as changeTypes
ORDER BY changeCount DESC
```

#### Benefits of Documentation-Centric Approach

**1. Staleness Prevention:**
- Documentation updates automatically propagate to code entities
- No need to maintain separate intent annotations
- Changes to docs invalidate and refresh related analyses

**2. Cluster-Level Analysis:**
- Business context lives at the appropriate granularity
- Clusters group related functionality naturally
- Easier to understand system architecture

**3. Maintainability:**
- Documentation is explicitly maintained by teams
- Clear ownership and update processes
- Easier to audit and verify accuracy

**4. Flexibility:**
- Can use simple pattern matching for most docs
- LLM enhancement only where needed
- Gradual adoption possible

#### API Integration Points

```typescript
interface DocumentationCentricAPI {
  // Documentation Management
  syncDocumentation(): Promise<void>;
  getDocumentationForEntity(entityId: string): Promise<DocumentationNode[]>;

  // Domain Analysis
  getBusinessDomains(): Promise<BusinessDomain[]>;
  getEntitiesByDomain(domainName: string): Promise<CodebaseEntity[]>;

  // Clustering
  getSemanticClusters(): Promise<SemanticCluster[]>;
  getClusterMembers(clusterId: string): Promise<CodebaseEntity[]>;

  // Business Intelligence
  getBusinessImpact(domainName: string, since: Date): Promise<BusinessImpact>;
  analyzeDomainDependencies(domainName: string): Promise<DomainDependencies>;
}
```

### Test Performance Integration

#### Test-to-Function Connection Architecture
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Test Runner   │────│  Test Parser    │────│ Knowledge Graph │
│ (Jest/Vitest)   │    │                 │    │   (FalkorDB)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Test Execution  │────│ Performance     │────│ Coverage Links  │
│   Results       │    │   Metrics       │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

#### Enhanced Test Node Types

##### PerformanceTest
**Tracks test performance metrics**
```
{
  ...Test,
  type: "performanceTest"
  averageExecutionTime: number (ms)
  p95ExecutionTime: number (ms)
  successRate: number (0-1)
  isFlaky: boolean
  lastFailureReason: string
  performanceTrend: string ("improving", "stable", "degrading")
  benchmarkValue?: number
  benchmarkUnit?: string ("ms", "MB", "ops/sec")
}
```

##### TestCoverageLink
**Connects tests to specific functions/code paths**
```
{
  id: string (UUID)
  type: "testCoverageLink"
  testId: string
  functionId: string
  coverageType: string ("unit", "integration", "e2e")
  codePaths: string[] (specific code paths tested)
  assertions: string[] (what the test validates)
  performanceImpact: number (how much test affects performance)
  lastExecuted: timestamp
  executionCount: number
}
```

#### Performance Relationship Types

##### PERFORMANCE_IMPACT
- **Source**: Function → Test
- **Properties**: execution time impact, resource usage, scalability impact

##### COVERAGE_PROVIDES
- **Source**: Test → Function
- **Properties**: coverage percentage, test quality score, confidence level

##### PERFORMANCE_REGRESSION
- **Source**: Change → Function
- **Properties**: performance delta, regression severity, affected tests

#### Test Performance Queries

**Find performance bottlenecks:**
```cypher
MATCH (f:Function)-[:TESTED_BY]->(t:PerformanceTest)
WHERE t.averageExecutionTime > 1000
RETURN f.name, t.averageExecutionTime, t.successRate
ORDER BY t.averageExecutionTime DESC
```

**Identify flaky tests:**
```cypher
MATCH (t:PerformanceTest)
WHERE t.isFlaky = true AND t.successRate < 0.95
MATCH (t)-[:TESTS]->(f:Function)
RETURN t.name, f.name, t.successRate, t.lastFailureReason
```

**Performance regression detection:**
```cypher
MATCH (c:Change)-[:AFFECTS]->(f:Function)
MATCH (f)-[:TESTED_BY]->(t:PerformanceTest)
WHERE t.performanceTrend = "degrading"
RETURN c.changeType, f.name, t.performanceTrend, c.timestamp
```

### Security Tooling Integration

#### Security Integration Architecture
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Security Tools │────│ Security Parser │────│ Knowledge Graph │
│ (SAST, SCA, etc)│    │                 │    │   (FalkorDB)    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                        │                        │
         ▼                        ▼                        ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│ Vulnerability   │────│ Security Issues │────│ Risk Assessment │
│   Scanner       │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

#### Security Node Types

##### SecurityIssue
**Security vulnerabilities and findings**
```
{
  id: string (UUID)
  type: "securityIssue"
  tool: string ("eslint-security", "semgrep", "snyk", "owasp-zap")
  ruleId: string
  severity: string ("critical", "high", "medium", "low", "info")
  title: string
  description: string
  cwe: string (Common Weakness Enumeration)
  owasp: string (OWASP category)
  affectedEntityId: string
  lineNumber: number
  codeSnippet: string
  remediation: string
  status: string ("open", "fixed", "accepted", "false-positive")
  discoveredAt: timestamp
  lastScanned: timestamp
  confidence: number (0-1)
}
```

##### Vulnerability
**Dependency vulnerabilities**
```
{
  id: string (UUID)
  type: "vulnerability"
  packageName: string
  version: string
  vulnerabilityId: string (CVE, GHSA, etc)
  severity: string
  description: string
  cvssScore: number
  affectedVersions: string
  fixedInVersion: string
  publishedAt: timestamp
  lastUpdated: timestamp
  exploitability: string ("high", "medium", "low")
}
```

#### Security Relationship Types

##### HAS_SECURITY_ISSUE
- **Source**: Entity → SecurityIssue
- **Properties**: severity, status, discovered date

##### DEPENDS_ON_VULNERABLE
- **Source**: Module → Vulnerability
- **Properties**: severity, exposure level, remediation status

##### SECURITY_IMPACTS
- **Source**: SecurityIssue → Function/File
- **Properties**: attack vector, potential impact, exploitability

#### Integrated Security Tools

**1. ESLint Security Rules:**
```javascript
// .eslintrc.js
{
  "plugins": ["security"],
  "extends": ["plugin:security/recommended"],
  "rules": {
    "security/detect-object-injection": "error",
    "security/detect-eval-with-expression": "error",
    "security/detect-no-csrf-before-method-override": "error"
  }
}
```

**2. SAST Tools (Semgrep, CodeQL):**
- Pattern-based vulnerability detection
- Custom rules for business-specific security issues
- Integration with CI/CD pipelines

**3. SCA Tools (Snyk, OWASP Dependency Check):**
- Dependency vulnerability scanning
- License compliance checking
- Outdated package detection

**4. Secret Detection:**
- API key detection
- Credential exposure prevention
- Integration with git hooks

#### Security Analysis Queries

**Critical security issues:**
```cypher
MATCH (si:SecurityIssue)
WHERE si.severity = "critical" AND si.status = "open"
MATCH (si)-[:HAS_SECURITY_ISSUE]->(entity)
RETURN si.title, entity.path, si.lineNumber, si.remediation
ORDER BY si.discoveredAt DESC
```

**Vulnerable dependencies:**
```cypher
MATCH (m:Module)-[:DEPENDS_ON_VULNERABLE]->(v:Vulnerability)
WHERE v.severity IN ["critical", "high"]
RETURN m.name, v.vulnerabilityId, v.cvssScore, v.fixedInVersion
ORDER BY v.cvssScore DESC
```

**Security debt by file:**
```cypher
MATCH (f:File)-[:HAS_SECURITY_ISSUE]->(si:SecurityIssue)
WHERE si.status = "open"
RETURN f.path,
       count(si) as issueCount,
       collect(si.severity) as severities,
       collect(si.title) as issues
ORDER BY issueCount DESC
```

### Integration Workflow

#### Combined Enhancement Pipeline
```
Code Change → Parse → LLM Analysis → Test Execution → Security Scan
      ↓            ↓            ↓            ↓            ↓
  Graph Update → Intent Store → Performance Record → Issue Creation → Risk Assessment
      ↓            ↓            ↓            ↓            ↓
  Impact Analysis → Business Context → Performance Alerts → Security Reports → Recommendations
```

#### API Integration Points
```typescript
interface EnhancedKnowledgeGraphAPI {
  // Documentation Integration
  syncDocumentation(): Promise<void>;
  getDocumentationForEntity(entityId: string): Promise<DocumentationNode[]>;

  // Domain Analysis
  getBusinessDomains(): Promise<BusinessDomain[]>;
  getEntitiesByDomain(domainName: string): Promise<CodebaseEntity[]>;

  // Test Integration
  recordTestExecution(testId: string, results: TestResults): Promise<void>;
  getPerformanceMetrics(functionId: string): Promise<PerformanceMetrics>;

  // Security Integration
  scanForSecurityIssues(entityId: string): Promise<SecurityIssue[]>;
  getVulnerabilityReport(): Promise<VulnerabilityReport>;

  // Clustering
  getSemanticClusters(): Promise<SemanticCluster[]>;
  getClusterMembers(clusterId: string): Promise<CodebaseEntity[]>;

  // Combined Analysis
  getEntityInsights(entityId: string): Promise<EntityInsights>;
}
```

#### Performance & Reliability Enhancements

**1. LLM Caching:**
- Cache LLM responses for similar code patterns
- Invalidate cache on code changes
- Fallback to rule-based analysis when LLM unavailable

**2. Test Performance Monitoring:**
- Track test execution times over time
- Alert on performance regressions
- Correlate test performance with code complexity

**3. Security Scan Scheduling:**
- Daily automated security scans
- On-demand scans for critical changes
- Incremental scans for modified files only

This enhanced knowledge graph would provide comprehensive insights into:
- **Business Context**: Why code exists and its business value
- **Performance Characteristics**: How code performs and scales
- **Security Posture**: Vulnerabilities and security issues
- **Quality Metrics**: Beyond structure to include semantic and performance quality

The system would transform from a structural code analyzer into a business-aware, performance-conscious, security-focused development intelligence platform.
</file>

<file path="MementoAPIDesign.md">
# Memento API Design

## Overview

The Memento API provides comprehensive access to the knowledge graph system, enabling AI agents and developers to interact with codebase analysis, documentation, testing, and security capabilities. The API is exposed through multiple interfaces:

- **MCP Server** (Claude Code compatible)
- **HTTP REST API** (OpenAI function-calling compatible)
- **WebSocket API** (Real-time updates)
- **MCP API** (Model Context Protocol for AI assistants)

## Core Concepts

### Response Types
```typescript
interface APIResponse<T> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  metadata?: {
    requestId: string;
    timestamp: Date;
    executionTime: number;
  };
}

interface PaginatedResponse<T> extends APIResponse<T[]> {
  pagination: {
    page: number;
    pageSize: number;
    total: number;
    hasMore: boolean;
  };
}
```

### Common Parameters
```typescript
interface BaseQueryParams {
  limit?: number;
  offset?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
  includeMetadata?: boolean;
}

interface TimeRangeParams {
  since?: Date;
  until?: Date;
  timeRange?: '1h' | '24h' | '7d' | '30d' | '90d';
}
```

---

## 1. Design & Specification Management

### 1.1 Create Specification
**Endpoint:** `POST /api/design/create-spec`
**MCP Tool:** `design.create_spec`

Creates and validates a feature specification with acceptance criteria.

```typescript
interface CreateSpecRequest {
  title: string;
  description: string;
  goals: string[];
  acceptanceCriteria: string[];
  priority?: 'low' | 'medium' | 'high' | 'critical';
  assignee?: string;
  tags?: string[];
  dependencies?: string[]; // Spec IDs this depends on
}

interface CreateSpecResponse {
  specId: string;
  spec: Spec;
  validationResults: {
    isValid: boolean;
    issues: ValidationIssue[];
    suggestions: string[];
  };
}

async function createSpec(params: CreateSpecRequest): Promise<CreateSpecResponse>
```

**Example:**
```typescript
const result = await createSpec({
  title: "User Authentication System",
  description: "Implement secure user login and registration",
  acceptanceCriteria: [
    "Users can register with email/password",
    "Users can login with valid credentials",
    "Invalid login attempts are rejected",
    "Passwords are securely hashed"
  ]
});
```

### 1.2 Get Specification
**Endpoint:** `GET /api/design/specs/{specId}`
**MCP Tool:** `design.get_spec`

Retrieves a specification with full details.

```typescript
interface GetSpecResponse {
  spec: Spec;
  relatedSpecs: Spec[];
  affectedEntities: CodebaseEntity[];
  testCoverage: TestCoverage;
  status: 'draft' | 'approved' | 'implemented' | 'deprecated';
}

async function getSpec(specId: string): Promise<GetSpecResponse>
```

### 1.3 Update Specification
**Endpoint:** `PUT /api/design/specs/{specId}`
**MCP Tool:** `design.update_spec`

Updates an existing specification.

```typescript
interface UpdateSpecRequest {
  title?: string;
  description?: string;
  acceptanceCriteria?: string[];
  status?: 'draft' | 'approved' | 'implemented' | 'deprecated';
  priority?: 'low' | 'medium' | 'high' | 'critical';
}

async function updateSpec(specId: string, updates: UpdateSpecRequest): Promise<Spec>
```

### 1.4 List Specifications
**Endpoint:** `GET /api/design/specs`
**MCP Tool:** `design.list_specs`

Lists specifications with filtering options.

```typescript
interface ListSpecsParams extends BaseQueryParams {
  status?: string[];
  priority?: string[];
  assignee?: string;
  tags?: string[];
  search?: string;
}

async function listSpecs(params?: ListSpecsParams): Promise<PaginatedResponse<Spec>>
```

---

## 2. Test Management

### 2.1 Plan and Generate Tests
**Endpoint:** `POST /api/tests/plan-and-generate`
**MCP Tool:** `tests.plan_and_generate`

Generates test plans and implementations for a specification.

```typescript
interface TestPlanRequest {
  specId: string;
  testTypes?: ('unit' | 'integration' | 'e2e')[];
  coverage?: {
    minLines?: number;
    minBranches?: number;
    minFunctions?: number;
  };
  includePerformanceTests?: boolean;
  includeSecurityTests?: boolean;
}

interface TestPlanResponse {
  testPlan: {
    unitTests: TestSpec[];
    integrationTests: TestSpec[];
    e2eTests: TestSpec[];
    performanceTests: TestSpec[];
  };
  estimatedCoverage: CoverageMetrics;
  changedFiles: string[];
}

async function planAndGenerateTests(params: TestPlanRequest): Promise<TestPlanResponse>
```

### 2.2 Record Test Execution
**Endpoint:** `POST /api/tests/record-execution`
**MCP Tool:** `tests.record_execution`

Records test execution results and updates performance metrics.

```typescript
interface TestExecutionResult {
  testId: string;
  testSuite: string;
  testName: string;
  status: 'passed' | 'failed' | 'skipped' | 'error';
  duration: number; // milliseconds
  errorMessage?: string;
  stackTrace?: string;
  coverage?: {
    lines: number;
    branches: number;
    functions: number;
    statements: number;
  };
  performance?: {
    memoryUsage?: number;
    cpuUsage?: number;
    networkRequests?: number;
  };
}

async function recordTestExecution(results: TestExecutionResult[]): Promise<void>
```

### 2.3 Get Performance Metrics
**Endpoint:** `GET /api/tests/performance/{entityId}`
**MCP Tool:** `tests.get_performance`

Retrieves performance metrics for a specific entity.

```typescript
interface PerformanceMetrics {
  entityId: string;
  averageExecutionTime: number;
  p95ExecutionTime: number;
  successRate: number;
  trend: 'improving' | 'stable' | 'degrading';
  benchmarkComparisons: {
    benchmark: string;
    value: number;
    status: 'above' | 'below' | 'at';
  }[];
  historicalData: {
    timestamp: Date;
    executionTime: number;
    successRate: number;
  }[];
}

async function getPerformanceMetrics(entityId: string): Promise<PerformanceMetrics>
```

### 2.4 Get Test Coverage
**Endpoint:** `GET /api/tests/coverage/{entityId}`
**MCP Tool:** `tests.get_coverage`

Retrieves test coverage information for an entity.

```typescript
interface TestCoverage {
  entityId: string;
  overallCoverage: CoverageMetrics;
  testBreakdown: {
    unitTests: CoverageMetrics;
    integrationTests: CoverageMetrics;
    e2eTests: CoverageMetrics;
  };
  uncoveredLines: number[];
  uncoveredBranches: number[];
  testCases: {
    testId: string;
    testName: string;
    covers: string[]; // Lines/branches covered
  }[];
}

async function getTestCoverage(entityId: string): Promise<TestCoverage>
```

---

## 3. Graph Operations

### 3.1 Graph Search
**Endpoint:** `POST /api/graph/search`
**MCP Tool:** `graph.search`

Performs semantic and structural searches over the knowledge graph.

```typescript
interface GraphSearchRequest {
  query: string;
  entityTypes?: ('function' | 'class' | 'interface' | 'file' | 'module')[];
  searchType?: 'semantic' | 'structural' | 'usage' | 'dependency';
  filters?: {
    language?: string;
    path?: string;
    tags?: string[];
    lastModified?: TimeRangeParams;
  };
  includeRelated?: boolean;
  limit?: number;
}

interface GraphSearchResult {
  entities: CodebaseEntity[];
  relationships: GraphRelationship[];
  clusters: SemanticCluster[];
  relevanceScore: number;
}

async function graphSearch(params: GraphSearchRequest): Promise<GraphSearchResult>
```

### 3.2 Get Graph Examples
**Endpoint:** `GET /api/graph/examples/{entityId}`
**MCP Tool:** `graph.examples`

Retrieves canonical usage examples and tests for an entity.

```typescript
interface GraphExamples {
  entityId: string;
  signature: string;
  usageExamples: {
    context: string;
    code: string;
    file: string;
    line: number;
  }[];
  testExamples: {
    testId: string;
    testName: string;
    testCode: string;
    assertions: string[];
  }[];
  relatedPatterns: {
    pattern: string;
    frequency: number;
    confidence: number;
  }[];
}

async function getGraphExamples(entityId: string): Promise<GraphExamples>
```

### 3.3 Get Entity Dependencies
**Endpoint:** `GET /api/graph/dependencies/{entityId}`
**MCP Tool:** `graph.get_dependencies`

Analyzes dependency relationships for an entity.

```typescript
interface DependencyAnalysis {
  entityId: string;
  directDependencies: {
    entity: CodebaseEntity;
    relationship: string;
    strength: number;
  }[];
  indirectDependencies: {
    entity: CodebaseEntity;
    path: CodebaseEntity[];
    relationship: string;
    distance: number;
  }[];
  reverseDependencies: {
    entity: CodebaseEntity;
    relationship: string;
    impact: 'high' | 'medium' | 'low';
  }[];
  circularDependencies: {
    cycle: CodebaseEntity[];
    severity: 'critical' | 'warning' | 'info';
  }[];
}

async function getEntityDependencies(entityId: string): Promise<DependencyAnalysis>
```

---

## 4. Code Operations

### 4.1 Propose Code Changes
**Endpoint:** `POST /api/code/propose-diff`
**MCP Tool:** `code.propose_diff`

Analyzes proposed code changes and their impact.

```typescript
interface CodeChangeProposal {
  changes: {
    file: string;
    type: 'create' | 'modify' | 'delete' | 'rename';
    oldContent?: string;
    newContent?: string;
    lineStart?: number;
    lineEnd?: number;
  }[];
  description: string;
  relatedSpecId?: string;
}

interface CodeChangeAnalysis {
  affectedEntities: CodebaseEntity[];
  breakingChanges: {
    severity: 'breaking' | 'potentially-breaking' | 'safe';
    description: string;
    affectedEntities: string[];
  }[];
  impactAnalysis: {
    directImpact: CodebaseEntity[];
    indirectImpact: CodebaseEntity[];
    testImpact: Test[];
  };
  recommendations: {
    type: 'warning' | 'suggestion' | 'requirement';
    message: string;
    actions: string[];
  }[];
}

async function proposeCodeChanges(proposal: CodeChangeProposal): Promise<CodeChangeAnalysis>
```

### 4.2 Validate Code
**Endpoint:** `POST /api/code/validate`
**MCP Tool:** `validate.run`

Runs comprehensive validation on code.

```typescript
interface ValidationRequest {
  files?: string[];
  specId?: string;
  includeTypes?: ('typescript' | 'eslint' | 'security' | 'tests' | 'coverage' | 'architecture')[];
  failOnWarnings?: boolean;
}

interface ValidationResult {
  overall: {
    passed: boolean;
    score: number; // 0-100
    duration: number;
  };
  typescript: {
    errors: number;
    warnings: number;
    issues: ValidationIssue[];
  };
  eslint: {
    errors: number;
    warnings: number;
    issues: ValidationIssue[];
  };
  security: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    issues: SecurityIssue[];
  };
  tests: {
    passed: number;
    failed: number;
    skipped: number;
    coverage: CoverageMetrics;
  };
  architecture: {
    violations: number;
    issues: ValidationIssue[];
  };
}

async function validateCode(params: ValidationRequest): Promise<ValidationResult>
```

---

## 5. Impact Analysis

### 5.1 Analyze Change Impact
**Endpoint:** `POST /api/impact/analyze`
**MCP Tool:** `impact.analyze`

Performs cascading impact analysis for proposed changes.

```typescript
interface ImpactAnalysisRequest {
  changes: {
    entityId: string;
    changeType: 'modify' | 'delete' | 'rename';
    newName?: string;
    signatureChange?: boolean;
  }[];
  includeIndirect?: boolean;
  maxDepth?: number;
}

interface ImpactAnalysis {
  directImpact: {
    entities: CodebaseEntity[];
    severity: 'high' | 'medium' | 'low';
    reason: string;
  }[];
  cascadingImpact: {
    level: number;
    entities: CodebaseEntity[];
    relationship: string;
    confidence: number;
  }[];
  testImpact: {
    affectedTests: Test[];
    requiredUpdates: string[];
    coverageImpact: number;
  };
  documentationImpact: {
    staleDocs: DocumentationNode[];
    requiredUpdates: string[];
  };
  recommendations: {
    priority: 'immediate' | 'planned' | 'optional';
    description: string;
    effort: 'low' | 'medium' | 'high';
    impact: 'breaking' | 'functional' | 'cosmetic';
  }[];
}

async function analyzeImpact(params: ImpactAnalysisRequest): Promise<ImpactAnalysis>
```

---

## 6. Vector Database Operations

### 6.1 Semantic Search
**Endpoint:** `POST /api/vdb/search`
**MCP Tool:** `vdb.search`

Performs semantic search with vector similarity.

```typescript
interface VectorSearchRequest {
  query: string;
  entityTypes?: string[];
  similarity?: number; // 0-1, minimum similarity threshold
  limit?: number;
  includeMetadata?: boolean;
  filters?: {
    language?: string;
    lastModified?: TimeRangeParams;
    tags?: string[];
  };
}

interface VectorSearchResult {
  results: {
    entity: CodebaseEntity;
    similarity: number;
    context: string;
    highlights: string[];
  }[];
  metadata: {
    totalResults: number;
    searchTime: number;
    indexSize: number;
  };
}

async function vectorSearch(params: VectorSearchRequest): Promise<VectorSearchResult>
```

---

## 7. Source Control Management

### 7.1 Create Commit/PR
**Endpoint:** `POST /api/scm/commit-pr`
**MCP Tool:** `scm.commit_pr`

Creates a commit and/or pull request with links to related artifacts.

```typescript
interface CommitPRRequest {
  title: string;
  description: string;
  changes: string[]; // File paths
  relatedSpecId?: string;
  testResults?: string[]; // Test IDs
  validationResults?: string; // Validation result ID
  createPR?: boolean;
  branchName?: string;
  labels?: string[];
}

interface CommitPRResponse {
  commitHash: string;
  prUrl?: string;
  branch: string;
  relatedArtifacts: {
    spec: Spec;
    tests: Test[];
    validation: ValidationResult;
  };
}

async function createCommitPR(params: CommitPRRequest): Promise<CommitPRResponse>
```

---

## 8. Documentation & Domain Analysis

### 8.1 Sync Documentation
**Endpoint:** `POST /api/docs/sync`
**MCP Tool:** `docs.sync`

Synchronizes documentation with the knowledge graph.

```typescript
interface SyncDocumentationResponse {
  processedFiles: number;
  newDomains: number;
  updatedClusters: number;
  errors: string[];
}

async function syncDocumentation(): Promise<SyncDocumentationResponse>
```

### 8.2 Get Business Domains
**Endpoint:** `GET /api/domains`
**MCP Tool:** `domains.get_business_domains`

Retrieves all business domains.

```typescript
interface BusinessDomain {
  id: string;
  name: string;
  description: string;
  criticality: 'core' | 'supporting' | 'utility';
  stakeholders: string[];
  keyProcesses: string[];
}

async function getBusinessDomains(): Promise<BusinessDomain[]>
```

### 8.3 Get Entities by Domain
**Endpoint:** `GET /api/domains/{domainName}/entities`
**MCP Tool:** `domains.get_entities`

Retrieves all code entities belonging to a business domain.

```typescript
async function getEntitiesByDomain(domainName: string): Promise<CodebaseEntity[]>
```

### 8.4 Get Semantic Clusters
**Endpoint:** `GET /api/clusters`
**MCP Tool:** `clusters.get_semantic_clusters`

Retrieves all semantic clusters.

```typescript
interface SemanticCluster {
  id: string;
  name: string;
  description: string;
  businessDomainId: string;
  clusterType: 'feature' | 'module' | 'capability' | 'service';
  cohesionScore: number;
  memberEntities: string[];
}

async function getSemanticClusters(): Promise<SemanticCluster[]>
```

### 8.5 Get Business Impact
**Endpoint:** `GET /api/business/impact/{domainName}`
**MCP Tool:** `business.get_impact`

Analyzes business impact of recent changes in a domain.

```typescript
interface BusinessImpact {
  domainName: string;
  timeRange: TimeRangeParams;
  changeVelocity: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  affectedCapabilities: string[];
  mitigationStrategies: string[];
}

async function getBusinessImpact(domainName: string, since?: Date): Promise<BusinessImpact>
```

---

## 9. Security Operations

### 9.1 Scan for Security Issues
**Endpoint:** `POST /api/security/scan`
**MCP Tool:** `security.scan`

Scans entities for security vulnerabilities.

```typescript
interface SecurityScanRequest {
  entityIds?: string[];
  scanTypes?: ('sast' | 'sca' | 'secrets' | 'dependency')[];
  severity?: ('critical' | 'high' | 'medium' | 'low')[];
}

interface SecurityScanResult {
  issues: SecurityIssue[];
  vulnerabilities: Vulnerability[];
  summary: {
    totalIssues: number;
    bySeverity: Record<string, number>;
    byType: Record<string, number>;
  };
}

async function scanForSecurityIssues(params?: SecurityScanRequest): Promise<SecurityScanResult>
```

### 9.2 Get Vulnerability Report
**Endpoint:** `GET /api/security/vulnerabilities`
**MCP Tool:** `security.get_vulnerability_report`

Retrieves vulnerability report for the entire codebase.

```typescript
interface VulnerabilityReport {
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  vulnerabilities: Vulnerability[];
  byPackage: Record<string, Vulnerability[]>;
  remediation: {
    immediate: string[];
    planned: string[];
    monitoring: string[];
  };
}

async function getVulnerabilityReport(): Promise<VulnerabilityReport>
```

---

## 10. Administration & Monitoring

### 10.1 Get System Health
**Endpoint:** `GET /api/health`
**MCP Tool:** `admin.get_health`

Retrieves system health status.

```typescript
interface SystemHealth {
  overall: 'healthy' | 'degraded' | 'unhealthy';
  components: {
    graphDatabase: ComponentHealth;
    vectorDatabase: ComponentHealth;
    fileWatcher: ComponentHealth;
    apiServer: ComponentHealth;
  };
  metrics: {
    uptime: number;
    totalEntities: number;
    totalRelationships: number;
    syncLatency: number;
    errorRate: number;
  };
}

async function getSystemHealth(): Promise<SystemHealth>
```

### 10.2 Get Sync Status
**Endpoint:** `GET /api/admin/sync-status`
**MCP Tool:** `admin.get_sync_status`

Retrieves synchronization status and queue information.

```typescript
interface SyncStatus {
  isActive: boolean;
  lastSync: Date;
  queueDepth: number;
  processingRate: number;
  errors: {
    count: number;
    recent: string[];
  };
  performance: {
    syncLatency: number;
    throughput: number;
    successRate: number;
  };
}

async function getSyncStatus(): Promise<SyncStatus>
```

### 10.3 Trigger Full Sync
**Endpoint:** `POST /api/admin/sync`
**MCP Tool:** `admin.trigger_sync`

Triggers a full synchronization of the knowledge graph.

```typescript
interface SyncOptions {
  force?: boolean;
  includeEmbeddings?: boolean;
  includeTests?: boolean;
  includeSecurity?: boolean;
}

async function triggerFullSync(options?: SyncOptions): Promise<{ jobId: string }>
```

### 10.4 Get Analytics
**Endpoint:** `GET /api/analytics`
**MCP Tool:** `admin.get_analytics`

Retrieves system analytics and usage metrics.

```typescript
interface SystemAnalytics {
  period: TimeRangeParams;
  usage: {
    apiCalls: number;
    uniqueUsers: number;
    popularEndpoints: Record<string, number>;
  };
  performance: {
    averageResponseTime: number;
    p95ResponseTime: number;
    errorRate: number;
  };
  content: {
    totalEntities: number;
    totalRelationships: number;
    growthRate: number;
    mostActiveDomains: string[];
  };
}

async function getAnalytics(params?: TimeRangeParams): Promise<SystemAnalytics>
```

---

## Error Handling

All API endpoints follow consistent error handling:

```typescript
interface APIError {
  code: 'VALIDATION_ERROR' | 'NOT_FOUND' | 'PERMISSION_DENIED' | 'INTERNAL_ERROR' | 'RATE_LIMITED';
  message: string;
  details?: any;
  requestId: string;
  timestamp: Date;
}

// Common HTTP status codes:
// 200 - Success
// 400 - Bad Request (validation errors)
// 401 - Unauthorized
// 403 - Forbidden
// 404 - Not Found
// 429 - Too Many Requests
// 500 - Internal Server Error
```

## Authentication & Authorization

```typescript
interface AuthenticatedRequest {
  headers: {
    'Authorization': `Bearer ${token}`;
    'X-API-Key'?: string;
    'X-Request-ID'?: string;
  };
}

// Role-based permissions:
// - 'read' - Basic read access
// - 'write' - Create/modify operations
// - 'admin' - Administrative operations
// - 'security' - Security-related operations
```

## Rate Limiting

```typescript
interface RateLimit {
  limit: number;
  remaining: number;
  resetTime: Date;
  retryAfter?: number;
}

// Headers returned:
// X-RateLimit-Limit
// X-RateLimit-Remaining
// X-RateLimit-Reset
// Retry-After (when limit exceeded)
```

## Webhooks & Real-time Updates

```typescript
interface WebhookConfig {
  url: string;
  events: ('sync.completed' | 'validation.failed' | 'security.alert')[];
  secret: string;
}

interface RealTimeSubscription {
  event: string;
  filter?: any;
  callback: (event: any) => void;
}

// WebSocket events:
// sync:update - Real-time sync progress
// validation:result - Validation completion
// security:alert - New security issues
// change:detected - Code changes detected
```

## Versioning

The API follows semantic versioning:

- **Major version** (v1, v2): Breaking changes
- **Minor version** (v1.1, v1.2): New features, backward compatible
- **Patch version** (v1.0.1): Bug fixes

Version is specified in:
- URL path: `/api/v1/design/create-spec`
- Header: `Accept-Version: v1`
- Query parameter: `?version=v1`

## SDKs & Client Libraries

Official client libraries available for:
- **JavaScript/TypeScript**: `npm install @memento-ai/sdk`
- **Python**: `pip install memento-ai`
- **Java**: Maven dependency
- **Go**: `go get github.com/memento-ai/go-sdk`

## Support & Documentation

- **Interactive API Documentation**: Available at `/api/docs`
- **OpenAPI Specification**: Available at `/api/openapi.json`

- **Community Forums**: `https://community.memento.ai`
- **Support**: `support@memento.ai`

---

*This API design provides comprehensive access to all Memento knowledge graph capabilities, enabling seamless integration with AI agents, IDEs, CI/CD pipelines, and development workflows.*
</file>

<file path="MementoArchitecture.md">
# Memento Architecture & Technology Stack

## System Overview

Memento is a **local-first AI coding assistant** that provides comprehensive codebase awareness through a knowledge graph system. Designed primarily for local development environments, it integrates documentation, testing, performance monitoring, and security analysis to enable intelligent code understanding and generation.

### Key Characteristics
- **Local-First**: Runs entirely on developer machines using Docker
- **AI-Native**: Built for AI coding assistants (Claude, GPT, etc.)
- **Knowledge Graph**: Maintains comprehensive codebase understanding
- **Multi-Protocol**: Supports MCP, REST, and WebSocket interfaces
- **Developer-Centric**: Optimized for individual and small team workflows

### Why Local-First Architecture?

#### Benefits for AI Coding Assistants
- **Instant Response**: No network latency for code analysis
- **Privacy**: Code never leaves the developer's machine
- **Offline Capability**: Works without internet connection
- **Full Context**: Direct access to entire codebase and dependencies
- **Cost-Effective**: No cloud infrastructure costs for individual developers

#### Perfect for Development Workflows
- **IDE Integration**: Seamless connection with local editors
- **File Watching**: Real-time updates as you code
- **Git Integration**: Works with local Git repositories
- **Multi-Project**: Easy switching between different projects
- **Resource Efficient**: Uses only necessary resources on local machine

## Core Architecture

```
┌─────────────────────────────────────────────────────────────────────┐
│                          Client Layer                                │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │   Claude Code   │ │   OpenAI       │ │   VS Code       │         │
│  │   (MCP)         │ │   (HTTP)       │ │   (WebSocket)   │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         API Gateway Layer                           │
│  ┌─────────────────┐ ┌─────────────────┐         │
│  │   MCP Server    │ │   REST API     │         │
│  │   (Local)       │ │   (Local)      │         │
│  └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                       Service Layer                                 │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │   Knowledge     │ │   Test         │ │   Security      │         │
│  │   Graph         │ │   Engine       │ │   Scanner       │         │
│  │   Service       │ │                 │ │                 │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Data Storage Layer                             │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │   Graph DB      │ │   Vector DB     │ │   Document      │         │
│  │   (Docker)      │ │   (Docker)      │ │   Store         │         │
│  │   FalkorDB      │ │   Qdrant        │ │   (Docker)      │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Infrastructure Layer                           │
│  ┌─────────────────┐ ┌─────────────────┐ ┌─────────────────┐         │
│  │   File System   │ │   Git           │ │   Docker        │         │
│  │   (Local)       │ │   (Local)       │ │   Compose       │         │
│  └─────────────────┘ └─────────────────┘ └─────────────────┘         │
└─────────────────────────────────────────────────────────────────────┘
```

## Technology Stack Decisions

### Core Runtime
- **Language**: TypeScript (Node.js)
- **Runtime**: Node.js 18+ (LTS)
- **Package Manager**: pnpm (for workspace management)

### Databases & Storage
- **Graph Database**: FalkorDB (Redis-based graph database)
  - **Why**: High performance, Redis compatibility, Cypher support
  - **Alternatives Considered**: Neo4j, Amazon Neptune
- **Vector Database**: Qdrant
  - **Why**: Fast similarity search, metadata filtering, horizontal scaling
  - **Alternatives Considered**: Pinecone, Weaviate
- **Document Store**: PostgreSQL with JSONB
  - **Why**: Structured data with flexible schemas, ACID compliance
  - **Alternatives Considered**: MongoDB, DynamoDB

### Frameworks & Libraries

#### Backend Framework
- **Web Framework**: Fastify
  - **Why**: High performance, plugin ecosystem, TypeScript support
  - **Alternatives Considered**: Express, Koa

#### Graph & Data Processing
- **Graph Processing**: Cypher (FalkorDB)
- **AST Parsing**: TypeScript Compiler API + ts-morph
- **Vector Embeddings**: OpenAI Ada-002 or local models (Transformers.js)
- **File Watching**: chokidar

#### External Integrations
- **LLM Integration**: OpenAI API + Anthropic Claude API
- **Git Integration**: isomorphic-git
- **Security Scanning**: ESLint security plugin, Semgrep, Snyk
- **Test Frameworks**: Jest, Vitest (auto-detection)

### Infrastructure & Deployment

#### Containerization
- **Container Runtime**: Docker
- **Orchestration**: Docker Compose (development) / Kubernetes (production)
- **Base Images**: Node.js Alpine Linux

#### Deployment Options

##### Primary: Local Development (Recommended)
- **Containerized**: Docker Compose for all services
- **Databases**: Local Docker containers for FalkorDB, Qdrant, PostgreSQL
- **IDE Integration**: Direct WebSocket/HTTP connections
- **File Access**: Direct filesystem access for code analysis

##### Optional: Cloud Deployment (Enterprise/Team Features)
- **Cloud Provider**: AWS/GCP/Azure (when scaling needed)
- **Compute**: ECS Fargate / EKS / Cloud Run
- **Storage**: RDS PostgreSQL, ElastiCache Redis, OpenSearch
- **CDN**: CloudFront / Cloud CDN (for distributed teams)
- **Monitoring**: CloudWatch / Cloud Monitoring

#### Development Environment
- **Local Development**: Docker Compose (primary workflow)
- **IDE Integration**: VS Code extensions, direct API connections
- **Package Management**: pnpm workspaces
- **Hot Reload**: Development mode with file watching

## Component Architecture

### 1. MCP Server Component

```typescript
// src/mcp/server.ts
import { Server } from '@modelcontextprotocol/sdk';

class MementoMCPServer extends Server {
  private knowledgeGraph: KnowledgeGraphService;
  private testEngine: TestEngine;
  private securityScanner: SecurityScanner;

  async handleToolCall(toolName: string, params: any): Promise<any> {
    switch (toolName) {
      case 'design.create_spec':
        return this.knowledgeGraph.createSpec(params);
      case 'tests.plan_and_generate':
        return this.testEngine.planTests(params);
      case 'graph.search':
        return this.knowledgeGraph.search(params);
      // ... other tools
    }
  }
}
```

### 2. Knowledge Graph Service

```typescript
// src/services/KnowledgeGraphService.ts
import { FalkorDB } from 'falkordb';
import { QdrantClient } from '@qdrant/js-client-rest';

class KnowledgeGraphService {
  private graphDb: FalkorDB;
  private vectorDb: QdrantClient;
  private fileWatcher: FileWatcher;

  async initialize(): Promise<void> {
    await this.graphDb.connect(process.env.FALKORDB_URL);
    await this.vectorDb.connect(process.env.QDRANT_URL);
    this.setupFileWatcher();
  }

  async createEntity(entity: CodebaseEntity): Promise<void> {
    // Create graph node
    await this.graphDb.query(`
      CREATE (e:${entity.type} {id: $id, path: $path, ...})
    `, entity);

    // Create vector embedding
    const embedding = await this.generateEmbedding(entity);
    await this.vectorDb.upsert(entity.id, embedding);

    // Update relationships
    await this.updateRelationships(entity);
  }
}
```

### 3. API Gateway

```typescript
// src/api/gateway.ts
import Fastify from 'fastify';
import { MCPRouter } from './mcp-router';
import { RestRouter } from './rest-router';

class APIGateway {
  private app: FastifyInstance;
  private mcpRouter: MCPRouter;
  private restRouter: RestRouter;

  async start(port: number): Promise<void> {
    // MCP endpoint
    this.app.register(this.mcpRouter.register, { prefix: '/mcp' });

    // REST API
    this.app.register(this.restRouter.register, { prefix: '/api/v1' });

    await this.app.listen({ port });
  }
}
```

## Data Flow Architecture

### Code Analysis Pipeline

```
File Change → File Watcher → Queue → Parser → Knowledge Graph → Vector DB
       ↓           ↓           ↓       ↓           ↓           ↓
  Detect Change → Debounce → Prioritize → AST → Create/Update → Embed
```

### Query Processing Flow

```
Query → API Gateway → Service Layer → Graph DB → Vector DB → Response
   ↓         ↓            ↓            ↓         ↓          ↓
Parse → Route → Validate → Cypher → Similarity → Format
```

### Synchronization Flow

```
Code Change → Change Detection → Impact Analysis → Update Graph → Update Vectors → Notify Clients
     ↓              ↓                ↓              ↓             ↓            ↓
File Event → Compare States → Find Affected → Apply Changes → Re-embed → WebSocket
```

## Security Architecture

### Authentication & Authorization
- **JWT Tokens** for API authentication
- **API Keys** for service-to-service communication
- **Role-Based Access Control** (RBAC)
- **OAuth 2.0** integration with GitHub/GitLab

### Data Protection
- **Encryption at Rest**: AES-256 for database storage
- **Encryption in Transit**: TLS 1.3 for all communications
- **Secret Management**: AWS Secrets Manager / HashiCorp Vault
- **Data Sanitization**: Input validation and SQL injection prevention

### Security Scanning Integration
- **SAST**: Static Application Security Testing
- **SCA**: Software Composition Analysis
- **Container Scanning**: Vulnerability scanning for Docker images
- **Secrets Detection**: Automated detection of exposed credentials

## Performance Architecture

### Caching Strategy
- **Application Cache**: Redis for frequently accessed data
- **Query Cache**: Graph query result caching
- **Embedding Cache**: Vector embedding caching
- **CDN**: Static asset caching

### Local Scaling Strategy
- **Resource Allocation**: Adjust Docker container memory/CPU based on project size
- **Database Optimization**: Configure FalkorDB/Qdrant for local hardware specs
- **Caching Strategy**: Optimize Redis caching for local performance
- **Concurrent Processing**: Handle multiple AI assistant sessions efficiently

### Optional Cloud Scaling (Enterprise)
- **Horizontal Scaling**: Multiple service instances across availability zones
- **Database Scaling**: Read replicas and clustering for graph/vector databases
- **Load Balancing**: Application Load Balancer with auto-scaling
- **CDN Integration**: Global distribution for distributed teams

### Performance Targets
- **API Response Time**: < 200ms for simple queries
- **Graph Query Time**: < 500ms for complex traversals
- **Vector Search Time**: < 100ms for similarity searches
- **File Sync Time**: < 5 seconds for typical file changes
- **Concurrent Users**: Support 1000+ simultaneous connections

## Monitoring & Observability

### Metrics Collection
- **Application Metrics**: Response times, error rates, throughput
- **System Metrics**: CPU, memory, disk usage
- **Business Metrics**: API usage, user engagement
- **Graph Metrics**: Node/relationship counts, query performance

### Logging Strategy
- **Structured Logging**: JSON format with correlation IDs
- **Log Levels**: ERROR, WARN, INFO, DEBUG
- **Log Aggregation**: Centralized logging with ELK stack
- **Audit Logging**: Security events and data access

### Alerting
- **Performance Alerts**: Response time degradation
- **Error Alerts**: Increased error rates
- **Security Alerts**: Suspicious activities
- **Capacity Alerts**: Resource utilization thresholds

## Development Workflow

### Local Development
```bash
# Start development environment
docker-compose up -d

# Run tests
pnpm test

# Build and run
pnpm build && pnpm start

# Run with hot reload
pnpm dev
```

### CI/CD Pipeline
```yaml
# .github/workflows/ci.yml
name: CI/CD
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
      - run: pnpm install
      - run: pnpm test
      - run: pnpm build
      - run: docker build -t memento-local .

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: pnpm audit
      - run: semgrep --config=auto

  integration-test:
    needs: [test, security]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: docker-compose up -d
      - run: sleep 30  # Wait for services to start
      - run: pnpm test:integration
      - run: docker-compose down

# Optional: Cloud deployment for enterprise use
  deploy-cloud:
    needs: [integration-test]
    if: github.ref == 'refs/heads/main' && contains(github.event.head_commit.message, '[deploy]')
    runs-on: ubuntu-latest
    steps:
      - uses: aws-actions/configure-aws-credentials@v2
      - run: aws ecs update-service --cluster memento --service memento-api --force-new-deployment
```

## Deployment Architecture

### Local Development Environment (Primary)
```yaml
# docker-compose.yml
version: '3.8'
services:
  memento-api:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=development
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      - falkordb
      - qdrant
      - postgres

  falkordb:
    image: falkordb/falkordb:latest
    ports:
      - "6379:6379"

  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "6333:6333"

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=memento
      - POSTGRES_USER=memento
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
```

### Production Environment
```yaml
# Kubernetes deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: memento-api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: memento-api
  template:
    metadata:
      labels:
        app: memento-api
    spec:
      containers:
      - name: memento-api
        image: memento/memento-api:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: FALKORDB_URL
          valueFrom:
            secretKeyRef:
              name: memento-secrets
              key: falkordb-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
```

## Directory Structure

```
memento/
├── src/
│   ├── api/                    # API endpoints and routers
│   │   ├── mcp-router.ts      # MCP server for Claude integration
│   │   ├── rest-router.ts     # REST API endpoints
│   │   ├── websocket-router.ts # Real-time WebSocket connections
│   │   └── middleware/        # Request validation, logging
│   ├── services/              # Core business logic services
│   │   ├── KnowledgeGraphService.ts
│   │   ├── TestEngine.ts
│   │   ├── SecurityScanner.ts
│   │   ├── DocumentationParser.ts
│   │   └── FileWatcher.ts
│   ├── models/                # Data models and schemas
│   │   ├── entities.ts        # Graph node type definitions
│   │   ├── relationships.ts   # Graph relationship definitions
│   │   └── types.ts           # TypeScript type definitions
│   ├── utils/                 # Utility functions and helpers
│   │   ├── ast-parser.ts      # TypeScript AST parsing
│   │   ├── embedding.ts       # Vector embedding generation
│   │   ├── git-integration.ts # Git repository operations
│   │   └── validation.ts      # Input validation helpers
│   └── index.ts               # Application entry point
├── tests/                     # Test suites and fixtures
│   ├── unit/                  # Unit tests
│   ├── integration/           # Integration tests
│   └── fixtures/              # Test data and mocks
├── docs/                      # Documentation and guides
├── docker/                    # Docker configuration
│   ├── Dockerfile             # Main application container
│   ├── docker-compose.yml     # Local development stack
│   └── docker-compose.test.yml # Testing environment
├── scripts/                   # Development and deployment scripts
│   ├── setup-dev.sh          # Development environment setup
│   ├── sync-knowledge-graph.sh # Manual graph synchronization
│   └── health-check.sh       # System health verification
├── config/                    # Configuration files
│   ├── default.json           # Default configuration
│   └── development.json       # Development overrides
├── package.json
├── tsconfig.json
├── eslint.config.js
└── README.md
```

## Technology Selection Rationale

### Why TypeScript?
- **Type Safety**: Prevents runtime errors through compile-time checking
- **Developer Experience**: Excellent IDE support and refactoring tools
- **Ecosystem**: Rich library ecosystem and community support
- **Node.js Compatibility**: Seamless integration with Node.js runtime

### Why FalkorDB over Neo4j?
- **Performance**: Redis-based architecture provides lower latency
- **Resource Usage**: Lighter memory footprint
- **Cypher Support**: Familiar query language
- **Cloud-Native**: Better containerization support

### Why Qdrant for Vector Search?
- **Performance**: Optimized for high-dimensional vector search
- **Metadata Filtering**: Advanced filtering capabilities
- **Horizontal Scaling**: Distributed architecture
- **API Compatibility**: REST and gRPC support

### Why Fastify over Express?
- **Performance**: Significantly faster than Express
- **Plugin Ecosystem**: Rich plugin architecture
- **TypeScript Support**: Built-in TypeScript definitions
- **Validation**: Built-in request/response validation

This architecture provides a solid foundation for building the Memento system, with clear separation of concerns, scalable components, and production-ready infrastructure patterns.
</file>

<file path="MementoReusableTools.md">
# Memento Reusable Tools Analysis

## Overview

This document catalogs industry-standard, officially maintained tools that can be reused for the Memento project instead of implementing functionality from scratch. All tools selected are actively maintained, have strong communities, and are considered production-ready.

## 1. Code Analysis & AST Parsing

### TypeScript AST Manipulation
**Tool:** `ts-morph` (v26.0.0)
- **Maintainer:** dsherret (TypeScript community)
- **Purpose:** TypeScript compiler wrapper for static analysis and code manipulation
- **Why Reuse:** Handles complex TypeScript AST operations, symbol resolution, refactoring
- **Usage:** Code parsing, symbol extraction, dependency analysis
- **Last Updated:** 3 months ago
- **License:** MIT
- **GitHub:** https://github.com/dsherret/ts-morph

### Multi-Language Parsing
**Tool:** `tree-sitter` (v0.25.0)
- **Maintainer:** Tree-sitter organization
- **Purpose:** Incremental parsing library for multiple programming languages
- **Why Reuse:** Fast, incremental parsing with excellent multi-language support
- **Usage:** Universal code parsing for various file types
- **Last Updated:** 2 months ago
- **License:** MIT
- **GitHub:** https://github.com/tree-sitter/tree-sitter

**Tool:** `tree-sitter-typescript` (v0.23.2)
- **Maintainer:** Tree-sitter organization
- **Purpose:** TypeScript and TSX grammars for tree-sitter
- **Why Reuse:** Official TypeScript parser with excellent accuracy
- **Usage:** TypeScript-specific parsing and AST generation
- **Last Updated:** 9 months ago
- **License:** MIT

## 2. Static Analysis & Security

### ESLint Security Rules
**Tool:** `eslint-plugin-security` (v3.0.1)
- **Maintainer:** ESLint Community
- **Purpose:** Security-focused ESLint rules
- **Why Reuse:** Comprehensive security rule set for Node.js applications
- **Usage:** Automated security vulnerability detection in code
- **Last Updated:** 1 year ago
- **License:** Apache-2.0
- **GitHub:** https://github.com/eslint-community/eslint-plugin-security

### Code Quality Analysis
**Tool:** ESLint (Official)
- **Maintainer:** ESLint organization
- **Purpose:** Pluggable linting utility for JavaScript and TypeScript
- **Why Reuse:** Industry standard for code quality analysis
- **Usage:** Code style enforcement, error detection, complexity analysis
- **License:** MIT
- **Official Site:** https://eslint.org

## 3. Web Framework & APIs

### High-Performance Web Server
**Tool:** `fastify` (v5.5.0)
- **Maintainer:** Fastify organization
- **Purpose:** Fast and low overhead web framework for Node.js
- **Why Reuse:** Significantly faster than Express, excellent plugin ecosystem
- **Usage:** Main API server, MCP server, WebSocket server
- **Last Updated:** 2 weeks ago
- **License:** MIT
- **GitHub:** https://github.com/fastify/fastify

### CORS Handling
**Tool:** `@fastify/cors` (v11.1.0)
- **Maintainer:** Fastify organization
- **Purpose:** CORS plugin for Fastify
- **Why Reuse:** Official Fastify CORS implementation
- **Usage:** Cross-origin request handling for web APIs
- **Last Updated:** 4 weeks ago
- **License:** MIT

### Model Context Protocol
**Tool:** `@modelcontextprotocol/sdk` (v1.17.4)
- **Maintainer:** Anthropic (official MCP implementation)
- **Purpose:** Model Context Protocol implementation for TypeScript
- **Why Reuse:** Official MCP SDK for Claude integration
- **Usage:** MCP server implementation for AI assistant integration
- **Last Updated:** 1 week ago
- **License:** MIT
- **Official Site:** https://modelcontextprotocol.io

## 4. File System & Monitoring

### File Watching
**Tool:** `chokidar` (v4.0.3)
- **Maintainer:** paulmillr
- **Purpose:** Minimal and efficient cross-platform file watching library
- **Why Reuse:** Most popular and reliable file watching library for Node.js
- **Usage:** Real-time file system monitoring for code changes
- **Last Updated:** 8 months ago
- **License:** MIT
- **GitHub:** https://github.com/paulmillr/chokidar

## 5. Testing Frameworks

### Unit Testing
**Tool:** `jest` (v30.1.1)
- **Maintainer:** Meta (Facebook) Open Source
- **Purpose:** Delightful JavaScript Testing framework
- **Why Reuse:** Industry standard testing framework with excellent TypeScript support
- **Usage:** Unit tests, integration tests, test coverage analysis
- **Last Updated:** 3 days ago
- **License:** MIT
- **Official Site:** https://jestjs.io

### API Testing
**Tool:** `supertest` (Standard choice)
- **Maintainer:** VisionMedia
- **Purpose:** HTTP endpoint testing library
- **Why Reuse:** De facto standard for testing HTTP APIs
- **Usage:** API endpoint testing, integration testing
- **License:** MIT

## 6. Documentation Processing

### Markdown Parsing
**Tool:** `marked` (v16.2.1)
- **Maintainer:** marked.js organization
- **Purpose:** Fast markdown parser and compiler
- **Why Reuse:** One of the fastest and most popular markdown parsers
- **Usage:** README parsing, documentation analysis, business context extraction
- **Last Updated:** 3 days ago
- **License:** MIT
- **Official Site:** https://marked.js.org

## 7. Databases & Storage

### Graph Database
**Tool:** FalkorDB (Official Docker image)
- **Maintainer:** FalkorDB organization
- **Purpose:** Redis-compatible graph database
- **Why Reuse:** High-performance graph database with Cypher support
- **Usage:** Knowledge graph storage and querying
- **License:** Redis Source Available License
- **Official Site:** https://falkordb.com

### Vector Database
**Tool:** Qdrant (Official Docker image)
- **Maintainer:** Qdrant organization
- **Purpose:** Vector similarity search engine
- **Why Reuse:** Fast, scalable vector search with metadata filtering
- **Usage:** Semantic code search, embedding storage and retrieval
- **License:** Apache-2.0
- **Official Site:** https://qdrant.tech

### Relational Database
**Tool:** PostgreSQL (Official Docker image)
- **Maintainer:** PostgreSQL Global Development Group
- **Purpose:** Advanced open source relational database
- **Why Reuse:** Robust, feature-rich database with JSON support
- **Usage:** Document storage, structured data, metadata storage
- **License:** PostgreSQL License
- **Official Site:** https://postgresql.org

## 8. Containerization & Orchestration

### Container Runtime
**Tool:** Docker (Official)
- **Maintainer:** Docker Inc.
- **Purpose:** Containerization platform
- **Why Reuse:** Industry standard for containerization
- **Usage:** Application containerization, service isolation
- **License:** Apache-2.0
- **Official Site:** https://docker.com

### Container Orchestration
**Tool:** Docker Compose (Official)
- **Maintainer:** Docker Inc.
- **Purpose:** Multi-container application definition and orchestration
- **Why Reuse:** Simple, effective orchestration for development
- **Usage:** Local development environment, service coordination
- **License:** Apache-2.0

## 9. Development Tools

### Package Management
**Tool:** `pnpm` (Official)
- **Maintainer:** pnpm organization
- **Purpose:** Fast, disk-efficient package manager
- **Why Reuse:** Modern alternative to npm with better performance
- **Usage:** Dependency management, workspace management
- **License:** MIT
- **Official Site:** https://pnpm.io

### Type Checking
**Tool:** TypeScript Compiler (Official)
- **Maintainer:** Microsoft
- **Purpose:** TypeScript compilation and type checking
- **Why Reuse:** Official TypeScript compiler
- **Usage:** Type checking, compilation, declaration file generation
- **License:** Apache-2.0
- **Official Site:** https://typescriptlang.org

## 10. Build Tools & Automation

### Task Running
**Tool:** `tsx` (Modern alternative to ts-node)
- **Maintainer:** esbuild organization
- **Purpose:** TypeScript execution and REPL
- **Why Reuse:** Fast TypeScript execution with esbuild
- **Usage:** Development scripts, testing, debugging
- **License:** MIT

## Tool Selection Criteria

All tools were selected based on these criteria:

### ✅ Industry Standard
- Widely adopted in the JavaScript/TypeScript ecosystem
- Recommended by official documentation
- Used by major companies and projects

### ✅ Active Maintenance
- Regular updates and security patches
- Active community and issue resolution
- Long-term support commitment

### ✅ Official & Trusted
- Official packages from maintainers
- Verified publishers and maintainers
- Security audited and trusted

### ✅ Performance & Reliability
- High performance and low resource usage
- Stable APIs and backward compatibility
- Production-ready and battle-tested

### ✅ Ecosystem Integration
- Good integration with other selected tools
- Rich plugin and extension ecosystem
- TypeScript support and type definitions

## Implementation Impact

### What We Can Reuse (Instead of Building):

1. **AST Parsing:** ts-morph + tree-sitter
2. **File Watching:** chokidar
3. **Web Server:** fastify
4. **Security Scanning:** eslint-plugin-security
5. **Testing:** jest + supertest
6. **Documentation Parsing:** marked
7. **MCP Integration:** @modelcontextprotocol/sdk

### What We Still Need to Build:

1. **Knowledge Graph Logic:** Business logic for graph operations
2. **Synchronization Engine:** File change to graph update coordination
3. **Embedding Generation:** Custom embedding logic for code
4. **MCP Tools:** Custom tool implementations for our domain
5. **Integration Orchestration:** Coordinating all components

## Maintenance & Updates

### Tool Monitoring Strategy:
- **Weekly:** Check for security updates via `pnpm audit`
- **Monthly:** Review release notes for major version updates
- **Quarterly:** Evaluate new tools that might provide better functionality

### Update Process:
1. **Security Updates:** Apply immediately when available
2. **Patch Updates:** Apply within 1-2 weeks
3. **Minor Updates:** Apply within 1 month
4. **Major Updates:** Evaluate compatibility and plan migration

This approach ensures we leverage the best of the ecosystem while focusing our development effort on the unique value proposition of Memento.
</file>

</files>
